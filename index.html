<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Vertical Recorder + Karaoke Subtitles (9:16)</title>
  <style>
    :root{
      --bg:#0b0c10;
      --panel:#12141a;
      --text:#eef1ff;
      --muted:rgba(238,241,255,.72);
      --line:rgba(255,255,255,.10);
      --accent:#ff2d55;
      --good:#31d158;
      --warn:#ffcc00;
      --shadow: 0 18px 50px rgba(0,0,0,.45);
      --r:18px;
      --safeTop: env(safe-area-inset-top);
      --safeBottom: env(safe-area-inset-bottom);
      --safeLeft: env(safe-area-inset-left);
      --safeRight: env(safe-area-inset-right);
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; margin:0; background:var(--bg); color:var(--text); font-family:var(--font); }
    button,input,textarea{ font-family:inherit; }
    .app{
      height:100%;
      display:flex;
      flex-direction:column;
      padding: calc(10px + var(--safeTop)) calc(10px + var(--safeRight)) calc(10px + var(--safeBottom)) calc(10px + var(--safeLeft));
      gap:10px;
      overflow:hidden;
    }

    .topbar{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding:10px 12px;
      background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.03));
      border:1px solid var(--line);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      flex: 0 0 auto;
    }
    .brand{ display:flex; align-items:center; gap:10px; font-weight:800; letter-spacing:.2px; }
    .dot{
      width:10px; height:10px; border-radius:50%;
      background: var(--accent);
      box-shadow: 0 0 0 6px rgba(255,45,85,.14);
      flex:0 0 auto;
    }
    .tabs{ display:flex; gap:8px; }
    .tab{
      border:1px solid var(--line);
      background: rgba(255,255,255,.04);
      color: var(--muted);
      padding:10px 12px;
      border-radius: 14px;
      font-weight:700;
      user-select:none;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, border-color .12s ease, opacity .12s ease;
    }
    .tab:active{ transform: scale(.98); }
    .tab.active{
      background: rgba(255,45,85,.12);
      border-color: rgba(255,45,85,.35);
      color: var(--text);
    }

    .screen{ flex: 1 1 auto; min-height:0; display:none; overflow:hidden; }
    .screen.active{ display:block; }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--line);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card .hd{ padding:12px 12px 0 12px; display:flex; justify-content:space-between; align-items:flex-start; gap:10px; }
    .card h2{ margin:0; font-size:14px; letter-spacing:.2px; opacity:.95; }
    .hint{ color:var(--muted); font-size:12px; line-height:1.35; }
    .body{ padding:12px; }

    .grid{ display:grid; grid-template-columns: 1fr; gap:10px; }
    @media (min-width: 920px){ .grid.two{ grid-template-columns: 1.05fr .95fr; } }

    .field label{
      display:flex; justify-content:space-between; align-items:center;
      color: var(--muted); font-size:12px; margin: 0 0 6px 2px;
    }
    .field input, .field textarea{
      width:100%;
      border:1px solid var(--line);
      background: rgba(0,0,0,.25);
      color: var(--text);
      border-radius: 14px;
      padding: 12px 12px;
      font-size: 15px;
      outline:none;
    }
    .field textarea{ min-height: 140px; resize: vertical; }

    .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }

    .btn{
      appearance:none;
      border:1px solid var(--line);
      background: rgba(255,255,255,.05);
      color: var(--text);
      padding: 12px 14px;
      border-radius: 16px;
      font-weight: 800;
      letter-spacing:.2px;
      cursor:pointer;
      user-select:none;
      transition: transform .12s ease, background .12s ease, border-color .12s ease, opacity .12s ease;
    }
    .btn:active{ transform: scale(.98); }
    .btn.primary{ background: rgba(255,45,85,.16); border-color: rgba(255,45,85,.35); }
    .btn.good{ background: rgba(49,209,88,.14); border-color: rgba(49,209,88,.35); }
    .btn.warn{ background: rgba(255,204,0,.12); border-color: rgba(255,204,0,.35); }
    .btn.ghost{ background: transparent; border-color: var(--line); color: var(--muted); font-weight: 750; }
    .btn:disabled{ opacity:.45; cursor:not-allowed; transform:none; }

    .templates{ display:grid; grid-template-columns: repeat(3, 1fr); gap:10px; }
    .templates .btn{ padding: 14px 10px; border-radius: 18px; font-size: 14px; }

    .overlay{
      position:fixed; inset:0; display:none; align-items:center; justify-content:center;
      padding: 18px calc(18px + var(--safeRight)) calc(18px + var(--safeBottom)) calc(18px + var(--safeLeft));
      background: rgba(0,0,0,.62);
      backdrop-filter: blur(10px);
      z-index: 60;
    }
    .overlay.show{ display:flex; }
    .overlay .sheet{
      width:min(680px, 100%);
      background: rgba(18,20,26,.92);
      border:1px solid rgba(255,255,255,.16);
      border-radius: 22px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .sheet .sheet-hd{ padding: 14px 14px 0 14px; display:flex; justify-content:space-between; align-items:center; gap:12px; }
    .sheet .sheet-hd .k{ font-weight:900; letter-spacing:.2px; }
    .sheet .content{
      padding: 10px 14px 14px 14px;
      color: rgba(238,241,255,.9);
      line-height:1.45;
      font-size: 16px;
      white-space: pre-wrap;
      word-break: break-word;
    }

    /* Recorder */
    .recWrap{ height:100%; display:grid; grid-template-rows: 1fr auto; gap: 10px; min-height:0; }
    .stage{
      position:relative;
      min-height:0;
      overflow:hidden;
      border-radius: 22px;
      border:1px solid var(--line);
      background: #000;
      box-shadow: var(--shadow);
      touch-action: manipulation;
    }
    .preview{
      position:absolute; inset:0; width:100%; height:100%;
      object-fit: cover; transform: scaleX(-1);
      background:#000;
    }
    .frame{
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      pointer-events:none;
    }
    .frame::before{
      content:"";
      width: min(100%, calc(100vh * 9 / 16));
      height: min(100%, calc(100vw * 16 / 9));
      aspect-ratio: 9/16;
      border-radius: 26px;
      border:1px solid rgba(255,255,255,.12);
      box-shadow: inset 0 0 0 9999px rgba(0,0,0,.02);
    }

    /* Hook pill (UI) */
    .hookUi{
      position:absolute; top: 14px; left: 14px; right: 14px;
      display:flex; justify-content:center;
      pointer-events:none; z-index: 6;
    }
    .hookPill{
      max-width: 95%;
      padding: 10px 12px;
      border-radius: 999px;
      background: rgba(0,0,0,.36);
      border:1px solid rgba(255,255,255,.14);
      font-weight: 900;
      letter-spacing:.2px;
      text-align:center;
      text-shadow: 0 2px 12px rgba(0,0,0,.55);
      color: rgba(255,255,255,.95);
      white-space: nowrap; overflow:hidden; text-overflow: ellipsis;
    }

    /* REC HUD (UI) */
    .recHud{
      position:absolute;
      top: 14px; right: 14px;
      display:flex; align-items:center; gap:8px;
      padding: 8px 10px;
      border-radius: 999px;
      background: rgba(0,0,0,.42);
      border:1px solid rgba(255,255,255,.14);
      z-index: 7;
      opacity: 0;
      transform: translateY(-6px);
      transition: opacity .16s ease, transform .16s ease;
      pointer-events:none;
    }
    .recHud.on{ opacity:1; transform: translateY(0); }
    .recBadge{
      width:10px; height:10px; border-radius:50%;
      background: var(--accent);
      box-shadow: 0 0 0 6px rgba(255,45,85,.16);
    }
    .recText{ font-weight: 900; letter-spacing:.6px; font-size: 12px; }

    /* Countdown */
    .countdown{
      position:absolute; inset:0;
      display:none; align-items:center; justify-content:center;
      z-index: 10;
      background: rgba(0,0,0,.45);
      backdrop-filter: blur(6px);
    }
    .countdown.show{ display:flex; }
    .countdown .num{
      font-size: 92px;
      font-weight: 1000;
      letter-spacing: -2px;
      text-shadow: 0 10px 35px rgba(0,0,0,.6);
    }

    /* Subtitle / karaoke strip (UI overlay) */
    .subUi{
      position:absolute;
      left: 50%;
      bottom: calc(14px + var(--safeBottom));
      transform: translateX(-50%);
      width: min(94%, 720px);
      padding: 10px 12px;
      border-radius: 16px;
      background: rgba(0,0,0,.46);
      border: 1px solid rgba(255,255,255,.14);
      backdrop-filter: blur(10px);
      z-index: 8;
      pointer-events:none;
      box-shadow: 0 14px 40px rgba(0,0,0,.35);
    }
    .subLine{
      font-size: 22px;
      line-height: 1.22;
      font-weight: 950;
      text-align:center;
      color: rgba(255,255,255,.92);
      text-shadow: 0 2px 14px rgba(0,0,0,.55);
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }
    .subLine .w{ opacity:.92; }
    .subLine .w.on{
      color: rgba(0,0,0,.92);
      background: rgba(255,204,0,.92);
      border-radius: 10px;
      padding: 2px 6px;
      margin: 0 2px;
      box-shadow: 0 8px 22px rgba(255,204,0,.18);
      text-shadow:none;
      opacity:1;
    }

    /* Controls under stage */
    .controls{ display:grid; grid-template-columns: 1fr; gap: 10px; }
    .tiny{ font-size:12px; color: var(--muted); }
    .sliders{
      display:grid; grid-template-columns: 1fr 1fr; gap:10px; align-items:center;
    }
    .sliders .s{ display:flex; flex-direction:column; gap:6px; }
    .sliders label{
      font-size:12px; color: var(--muted);
      display:flex; justify-content:space-between;
    }
    input[type="range"]{ width:100%; accent-color: var(--accent); }

    /* Big REC button */
    .recBtnWrap{ display:flex; justify-content:center; padding: 6px 0; }
    .recBtn{
      width: 86px; height: 86px;
      border-radius: 999px;
      border: 2px solid rgba(255,255,255,.22);
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.12), rgba(255,255,255,.03) 60%, rgba(0,0,0,.12));
      display:grid; place-items:center;
      box-shadow: var(--shadow);
      cursor:pointer;
      user-select:none;
      transition: transform .12s ease;
    }
    .recBtn:active{ transform: scale(.98); }
    .recCore{
      width: 62px; height: 62px;
      border-radius: 999px;
      background: var(--accent);
      display:grid; place-items:center;
      box-shadow: 0 12px 30px rgba(255,45,85,.25);
      border: 1px solid rgba(0,0,0,.25);
    }
    .stopSquare{
      width: 22px; height: 22px;
      border-radius: 5px;
      background: rgba(255,255,255,.92);
      transition: all .12s ease;
    }
    .recBtn.recording .recCore{ background: rgba(255,45,85,.95); box-shadow: 0 16px 40px rgba(255,45,85,.35); }
    .recBtn.recording .stopSquare{ width: 24px; height: 24px; }

    /* Feed */
    .feedWrap{ height:100%; overflow:hidden; display:grid; grid-template-rows: auto 1fr; gap:10px; min-height:0; }
    .feedList{
      min-height:0; overflow:auto;
      scroll-snap-type: y mandatory;
      border-radius: 22px;
      border:1px solid var(--line);
      box-shadow: var(--shadow);
      background:#000;
    }
    .feedItem{
      position:relative;
      height: calc(100vh - 190px);
      min-height: 560px;
      scroll-snap-align: start;
      background:#000;
      border-bottom: 1px solid rgba(255,255,255,.08);
      overflow:hidden;
    }
    .feedItem video{ position:absolute; inset:0; width:100%; height:100%; object-fit:cover; background:#000; }
    .feedMeta{
      position:absolute; left: 14px; right: 14px; bottom: 14px;
      z-index: 5; display:flex; flex-direction:column; gap:10px; pointer-events:none;
    }
    .feedMeta .pill{
      display:inline-flex; align-self:flex-start; gap:8px; align-items:center;
      padding: 10px 12px; border-radius: 18px;
      background: rgba(0,0,0,.42);
      border:1px solid rgba(255,255,255,.14);
      backdrop-filter: blur(8px);
      max-width: 100%;
    }
    .feedMeta .title{ font-weight: 950; white-space: nowrap; overflow:hidden; text-overflow: ellipsis; }
    .feedMeta .tags{ color: rgba(238,241,255,.8); font-size: 12px; white-space: nowrap; overflow:hidden; text-overflow: ellipsis; }
    .feedActions{
      position:absolute; right: 12px; top: 50%;
      transform: translateY(-50%);
      z-index: 6;
      display:flex; flex-direction:column; gap:10px; pointer-events:auto;
    }
    .fab{
      width: 52px; height: 52px;
      border-radius: 999px;
      display:grid; place-items:center;
      background: rgba(0,0,0,.42);
      border:1px solid rgba(255,255,255,.16);
      backdrop-filter: blur(8px);
      cursor:pointer; user-select:none; font-weight: 1000;
    }
    .fab small{ font-size: 10px; opacity:.9; letter-spacing:.3px; }
    .empty{
      height:100%;
      display:grid; place-items:center;
      padding: 30px; color: var(--muted); text-align:center;
    }
    .empty .big{ color: rgba(238,241,255,.92); font-weight: 950; font-size: 18px; margin-bottom: 6px; }

    /* Toast */
    .toasts{
      position: fixed; left: 0; right: 0;
      bottom: calc(12px + var(--safeBottom));
      display:flex; justify-content:center;
      pointer-events:none; z-index: 80;
      padding: 0 12px;
    }
    .toast{
      max-width: min(720px, 100%);
      background: rgba(18,20,26,.92);
      border:1px solid rgba(255,255,255,.16);
      border-radius: 18px;
      box-shadow: var(--shadow);
      padding: 12px 14px;
      display:flex; gap:10px; align-items:flex-start;
      transform: translateY(12px);
      opacity:0;
      transition: opacity .18s ease, transform .18s ease;
      backdrop-filter: blur(10px);
    }
    .toast.show{ opacity:1; transform: translateY(0); }
    .toast .icon{
      width: 10px; height: 10px; border-radius:50%;
      margin-top: 4px;
      background: var(--warn);
      box-shadow: 0 0 0 6px rgba(255,204,0,.16);
      flex:0 0 auto;
    }
    .toast.good .icon{ background: var(--good); box-shadow: 0 0 0 6px rgba(49,209,88,.16); }
    .toast.bad .icon{ background: var(--accent); box-shadow: 0 0 0 6px rgba(255,45,85,.16); }
    .toast .msg{ font-size: 14px; line-height: 1.25; color: rgba(238,241,255,.92); word-break: break-word; }

    /* Review modal */
    .modal{
      position:fixed; inset:0;
      display:none; align-items:center; justify-content:center;
      background: rgba(0,0,0,.62);
      backdrop-filter: blur(10px);
      padding: 18px calc(18px + var(--safeRight)) calc(18px + var(--safeBottom)) calc(18px + var(--safeLeft));
      z-index: 70;
    }
    .modal.show{ display:flex; }
    .modal .box{
      width: min(760px, 100%);
      background: rgba(18,20,26,.94);
      border:1px solid rgba(255,255,255,.16);
      border-radius: 22px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .modal .box .hd{ padding: 14px 14px 10px 14px; display:flex; justify-content:space-between; align-items:center; gap:10px; }
    .modal .box .hd strong{ font-weight: 1000; }
    .modal .box .bd{ padding: 0 14px 14px 14px; display:grid; gap: 12px; }
    .reviewVid{
      width:100%;
      aspect-ratio: 9/16;
      border-radius: 18px;
      border:1px solid rgba(255,255,255,.12);
      background:#000;
      object-fit:cover;
    }
    .modal .actions{ display:flex; gap:10px; flex-wrap:wrap; }
  </style>
</head>

<body>
  <div class="app">
    <div class="topbar">
      <div class="brand"><div class="dot"></div><div>Vertical Recorder</div></div>
      <div class="tabs">
        <button class="tab active" id="tabScript">Script</button>
        <button class="tab" id="tabRec">Recorder</button>
        <button class="tab" id="tabFeed">Feed</button>
      </div>
    </div>

    <!-- SCREEN: SCRIPT BUILDER -->
    <section class="screen active" id="screenScript">
      <div class="grid two" style="height:100%; min-height:0;">
        <div class="card" style="min-height:0; display:flex; flex-direction:column;">
          <div class="hd">
            <div>
              <h2>Flusso forzato: Domanda ‚Üí Risposta ‚Üí Invia al teleprompter</h2>
              <div class="hint">Premi <b>INVIA</b>, guarda l‚Äôoverlay, poi <b>CHIUDI</b>. Poi invia al teleprompter.</div>
            </div>
          </div>
          <div class="body" style="min-height:0; overflow:auto;">
            <div class="grid">
              <div class="field">
                <label>Domanda (Hook) <span id="qCount">0</span></label>
                <textarea id="questionInput" placeholder="Esempio: Perch√© il 90% delle case resta invenduto per mesi?"></textarea>
              </div>
              <div class="row">
                <button class="btn primary" id="sendQuestionBtn">INVIA (Domanda)</button>
                <span class="tiny">Obbligatorio: appare in overlay.</span>
              </div>

              <div class="field">
                <label>Risposta (Script) <span id="aCount">0</span></label>
                <textarea id="answerInput" placeholder="Incolla o scrivi la risposta completa..."></textarea>
              </div>
              <div class="row">
                <button class="btn primary" id="sendAnswerBtn">INVIA (Risposta)</button>
                <span class="tiny">Obbligatorio: appare in overlay.</span>
              </div>

              <div class="row">
                <button class="btn good" id="pushToTeleprompterBtn">Invia al teleprompter</button>
                <button class="btn ghost" id="goRecorderBtn">Apri Recorder</button>
              </div>

              <div class="card" style="padding:12px;">
                <div class="row" style="justify-content:space-between;">
                  <div>
                    <div style="font-weight:950;">Caption standard (forzata)</div>
                    <div class="tiny">Hook + hashtag + firma fissa.</div>
                  </div>
                  <button class="btn ghost" id="copyCaptionBtn">Copia</button>
                </div>
                <div id="captionPreview" class="hint" style="margin-top:10px; white-space:pre-wrap;"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="card" style="min-height:0; display:flex; flex-direction:column;">
          <div class="hd">
            <div>
              <h2>Template rapidi (1 tap)</h2>
              <div class="hint">Riempiono Hook + Script e aggiungono la frase di <b>loop</b>.</div>
            </div>
          </div>
          <div class="body" style="min-height:0; overflow:auto;">
            <div class="templates">
              <button class="btn" id="tplA">Errore comune</button>
              <button class="btn" id="tplB">3 Step</button>
              <button class="btn" id="tplC">Sfata un mito</button>
            </div>

            <div style="height:12px;"></div>

            <div class="card" style="padding:12px;">
              <div style="font-weight:950; margin-bottom:6px;">Logo (persistente)</div>
              <div class="hint" style="margin-bottom:10px;">Salvato in IndexedDB e burn-in nel video (alto a destra).</div>
              <div class="row">
                <button class="btn" id="logoBtn">Carica logo</button>
                <button class="btn ghost" id="removeLogoBtn">Rimuovi</button>
                <span class="tiny" id="logoStatus">Nessun logo</span>
              </div>
            </div>

            <div style="height:12px;"></div>

            <div class="card" style="padding:12px;">
              <div style="font-weight:950; margin-bottom:6px;">Teleprompter ‚Äúsottotitolo karaoke‚Äù</div>
              <div class="hint">Sempre ON nel recorder: una riga alla volta in basso, parole evidenziate automaticamente (stile karaoke).</div>
            </div>

            <div style="height:12px;"></div>

            <div class="card" style="padding:12px;">
              <div style="font-weight:950; margin-bottom:6px;">Gate di registrazione (hard)</div>
              <div class="hint">Hook min <b>12</b> ¬∑ Script min <b>40</b> ¬∑ Countdown sempre ON ¬∑ Durata max <b>60s</b>.</div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- SCREEN: RECORDER -->
    <section class="screen" id="screenRecorder">
      <div class="recWrap">
        <div class="stage" id="stage">
          <video id="livePreview" class="preview" autoplay playsinline muted></video>

          <div class="hookUi">
            <div class="hookPill" id="hookUiText">Hook‚Ä¶</div>
          </div>

          <div class="recHud" id="recHud">
            <div class="recBadge"></div><div class="recText">REC</div>
          </div>

          <!-- Karaoke subtitles overlay (UI) -->
          <div class="subUi" aria-hidden="true">
            <div class="subLine" id="subUiLine">‚Äî</div>
          </div>

          <div class="countdown" id="countdown">
            <div class="num" id="countNum">3</div>
          </div>

          <div class="frame" aria-hidden="true"></div>
        </div>

        <div class="controls">
          <div class="card">
            <div class="sliders">
              <div class="s">
                <label>Zoom <span id="zoomVal">1.00√ó</span></label>
                <input id="zoomRange" type="range" min="1" max="1.35" step="0.01" value="1.00" />
              </div>
              <div class="s">
                <label>Velocit√† <span id="spdVal">150 wpm</span></label>
                <input id="speedRange" type="range" min="110" max="200" step="1" value="150" />
              </div>
            </div>
          </div>

          <div class="card">
            <div class="row" style="justify-content:space-between;">
              <div class="tiny" id="recStatus">Pronto. Sottotitolo karaoke sempre ON.</div>
              <div class="tiny" id="timeLeft">60s</div>
            </div>
            <div class="recBtnWrap">
              <div class="recBtn" id="recBtn" role="button" aria-label="REC">
                <div class="recCore"><div class="stopSquare"></div></div>
              </div>
            </div>
            <div class="row" style="justify-content:space-between;">
              <button class="btn ghost" id="backToScriptBtn">‚Üê Script</button>
              <button class="btn ghost" id="openFeedBtn">Feed ‚Üí</button>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- SCREEN: FEED -->
    <section class="screen" id="screenFeed">
      <div class="feedWrap">
        <div class="card" style="padding:12px;">
          <div class="row" style="justify-content:space-between; align-items:flex-start;">
            <div>
              <div style="font-weight:950;">Archivio</div>
              <div class="hint">Scorri verticale. Autoplay solo del video visibile.</div>
            </div>
            <div class="row">
              <button class="btn ghost" id="feedToRecBtn">‚Üê Recorder</button>
              <button class="btn warn" id="wipeAllBtn">Svuota</button>
            </div>
          </div>
        </div>
        <div class="feedList" id="feedList"></div>
      </div>
    </section>
  </div>

  <!-- Overlay sheet -->
  <div class="overlay" id="textOverlay" aria-hidden="true">
    <div class="sheet">
      <div class="sheet-hd">
        <div class="k" id="overlayTitle">Overlay</div>
        <button class="btn ghost" id="closeOverlayBtn">Chiudi</button>
      </div>
      <div class="content" id="overlayContent"></div>
    </div>
  </div>

  <!-- Review modal -->
  <div class="modal" id="reviewModal" aria-hidden="true">
    <div class="box">
      <div class="hd">
        <strong>Clip pronta</strong>
        <button class="btn ghost" id="closeReviewBtn">Chiudi</button>
      </div>
      <div class="bd">
        <video class="reviewVid" id="reviewVideo" controls playsinline></video>
        <div class="actions">
          <button class="btn good" id="saveClipBtn">Salva nel feed</button>
          <button class="btn primary" id="downloadClipBtn">Download</button>
          <button class="btn ghost" id="discardClipBtn">Scarta</button>
        </div>
        <div class="hint" id="reviewMeta"></div>
      </div>
    </div>
  </div>

  <!-- Toast -->
  <div class="toasts" aria-live="polite" aria-atomic="true">
    <div class="toast" id="toast">
      <div class="icon"></div>
      <div class="msg" id="toastMsg">‚Äî</div>
    </div>
  </div>

  <!-- Hidden inputs -->
  <input id="logoInput" type="file" accept="image/*" hidden />

  <script>
    /*****************************************************************
     * 0) Utils (toast, sleep, download)
     *****************************************************************/
    const $ = (s)=>document.querySelector(s);
    const $$ = (s)=>Array.from(document.querySelectorAll(s));
    const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));
    const clamp=(n,a,b)=>Math.max(a,Math.min(b,n));

    const toastEl = $("#toast");
    const toastMsg = $("#toastMsg");
    let toastTimer=null;
    function showToast(msg,type="bad"){
      toastEl.classList.remove("good","bad");
      toastEl.classList.add(type);
      toastMsg.textContent=msg;
      toastEl.classList.add("show");
      clearTimeout(toastTimer);
      toastTimer=setTimeout(()=>toastEl.classList.remove("show"),2200);
    }
    function downloadBlob(blob, filename){
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = filename;
      document.body.appendChild(a);
      a.click(); a.remove();
      setTimeout(()=>URL.revokeObjectURL(url),1200);
    }

    /*****************************************************************
     * 1) IndexedDB (logo + clips)
     *****************************************************************/
    const DB_NAME="vertical_recorder_db";
    const DB_VER=1;
    let db=null;

    function openDB(){
      return new Promise((resolve,reject)=>{
        const req=indexedDB.open(DB_NAME,DB_VER);
        req.onupgradeneeded=()=>{
          const d=req.result;
          if(!d.objectStoreNames.contains("settings")) d.createObjectStore("settings");
          if(!d.objectStoreNames.contains("clips")){
            const st=d.createObjectStore("clips",{keyPath:"id",autoIncrement:true});
            st.createIndex("createdAt","createdAt");
          }
        };
        req.onsuccess=()=>resolve(req.result);
        req.onerror=()=>reject(req.error);
      });
    }
    const idbGet=(store,key)=>new Promise((resolve,reject)=>{
      const tx=db.transaction(store,"readonly");
      const st=tx.objectStore(store);
      const req=st.get(key);
      req.onsuccess=()=>resolve(req.result);
      req.onerror=()=>reject(req.error);
    });
    const idbPut=(store,key,val)=>new Promise((resolve,reject)=>{
      const tx=db.transaction(store,"readwrite");
      const st=tx.objectStore(store);
      const req=st.put(val,key);
      req.onsuccess=()=>resolve(true);
      req.onerror=()=>reject(req.error);
    });
    const idbDel=(store,key)=>new Promise((resolve,reject)=>{
      const tx=db.transaction(store,"readwrite");
      const st=tx.objectStore(store);
      const req=st.delete(key);
      req.onsuccess=()=>resolve(true);
      req.onerror=()=>reject(req.error);
    });
    const idbAddClip=(clip)=>new Promise((resolve,reject)=>{
      const tx=db.transaction("clips","readwrite");
      const st=tx.objectStore("clips");
      const req=st.add(clip);
      req.onsuccess=()=>resolve(req.result);
      req.onerror=()=>reject(req.error);
    });
    const idbGetAllClips=()=>new Promise((resolve,reject)=>{
      const tx=db.transaction("clips","readonly");
      const st=tx.objectStore("clips");
      const req=st.getAll();
      req.onsuccess=()=>resolve(req.result||[]);
      req.onerror=()=>reject(req.error);
    });

    /*****************************************************************
     * 2) Product rules / constants
     *****************************************************************/
    const DEFAULT_TAGS=["#immobiliare","#realestate","#marketing","#socialmedia","#content"]; // max 5
    const FIXED_SIGNATURE=
`geometra Christian Raimondi
Immobiliare La Sacra

üìû 346 256 8685
üìß immobiliarelasacra@gmail.com`;

    const LOOP_PREFIX="Se ti sei perso l‚Äôinizio, rivedilo:";
    const MAX_SECONDS=60;
    const COUNTDOWN_ON=true;

    /*****************************************************************
     * 3) App state
     *****************************************************************/
    const state={
      hook:"",
      script:"",
      caption:"",
      // logo
      logoBlob:null,
      logoBitmap:null,
      logoAspect:1,
      // karaoke (teleprompter)
      words:[],                // token list
      tokenIndex:0,            // global word index
      wpm:150,                 // speed control
      wps:150/60,              // derived
      phraseSize:10,           // words visible at once
      phraseShiftEvery:1,      // shift by 1 word per step
      karaokeStartTs:0,        // performance.now baseline
      karaokeRunning:false,    // always ON in recorder
      // recorder
      stream:null,
      audioTrack:null,
      cameraReady:false,
      recording:false,
      recorder:null,
      chunks:[],
      recordedBlob:null,
      recordStartTs:0,
      stopTimer:null,
      // canvas render
      canvas:null,
      ctx:null,
      rafId:null,
      lastFrameTs:0,
      // ui loop
      uiRaf:null
    };

    function buildCaption(){
      const hook=(state.hook||"").trim();
      const tags=DEFAULT_TAGS.slice(0,5).join(" ");
      const firstLine=hook?hook:"‚Äî";
      state.caption=`${firstLine}\n${tags}\n\n${FIXED_SIGNATURE}`;
      $("#captionPreview").textContent=state.caption;
    }

    function ensureLoopLine(){
      const hook=(state.hook||"").trim();
      if(!hook) return;
      const loopLine=`${LOOP_PREFIX} ${hook}`;
      const s=(state.script||"").trim();
      if(!s) return;
      if(!s.toLowerCase().includes(LOOP_PREFIX.toLowerCase())){
        state.script=s.replace(/\s+$/,"")+"\n\n"+loopLine;
      }
    }

    function updateRecorderUITexts(){
      $("#hookUiText").textContent=(state.hook||"Hook‚Ä¶").trim()||"Hook‚Ä¶";
      buildCaption();
      // rebuild karaoke tokens anytime script changes (keeps it readable)
      rebuildKaraokeTokens();
    }

    /*****************************************************************
     * 4) Hard gates (start REC only if ready)
     *****************************************************************/
    function canStartRec(){
      const hook=(state.hook||"").trim();
      const script=(state.script||"").trim();
      if(hook.length<12){
        showToast("Scrivi un hook chiaro (min 12 caratteri)","bad");
        $("#questionInput").focus();
        return false;
      }
      if(script.length<40){
        showToast("Scrivi uno script teleprompter (min 40 caratteri)","bad");
        $("#answerInput").focus();
        return false;
      }
      const v=$("#livePreview");
      if(!state.stream || !v.srcObject || !(v.videoWidth>0)){
        showToast("Avvio camera‚Ä¶ concedi i permessi.","bad");
        startCamera().catch(()=>{});
        return false;
      }
      return true;
    }

    /*****************************************************************
     * 5) Navigation
     *****************************************************************/
    const screens={ script:$("#screenScript"), recorder:$("#screenRecorder"), feed:$("#screenFeed") };
    function setTab(active){
      $("#tabScript").classList.toggle("active",active==="script");
      $("#tabRec").classList.toggle("active",active==="recorder");
      $("#tabFeed").classList.toggle("active",active==="feed");
      Object.keys(screens).forEach(k=>screens[k].classList.toggle("active",k===active));
    }
    function openScript(){ setTab("script"); }
    async function openRecorder(){
      setTab("recorder");
      // camera auto-start (required)
      await startCamera().catch(()=>{});
      // karaoke always ON when recorder open
      startKaraokeUI();
      updateRecorderUITexts();
    }
    async function openFeed(){
      setTab("feed");
      await renderFeed();
    }

    /*****************************************************************
     * 6) Overlay flow (Domanda/Risposta)
     *****************************************************************/
    const overlay=$("#textOverlay");
    const overlayTitle=$("#overlayTitle");
    const overlayContent=$("#overlayContent");
    function showOverlay(title,text){
      overlayTitle.textContent=title;
      overlayContent.textContent=text;
      overlay.classList.add("show");
      overlay.setAttribute("aria-hidden","false");
    }
    function closeOverlay(){
      overlay.classList.remove("show");
      overlay.setAttribute("aria-hidden","true");
    }
    $("#closeOverlayBtn").addEventListener("click",closeOverlay);
    overlay.addEventListener("click",(e)=>{ if(e.target===overlay) closeOverlay(); });

    /*****************************************************************
     * 7) Templates (social/marketing)
     *****************************************************************/
    function applyTemplate(kind){
      const t={
        A:{
          hook:"L‚Äôerrore pi√π comune quando metti in vendita casa: puntare tutto sul prezzo.",
          script:
`Se vuoi vendere velocemente, il prezzo conta‚Ä¶ ma non √® l‚Äôunica leva.
L‚Äôerrore pi√π comune √® ‚Äútagliare‚Äù il prezzo senza sistemare il contesto.

Ecco cosa funziona meglio:
1) Foto e video che fanno percepire valore (luce, ordine, angoli giusti).
2) Descrizione che risponde alle obiezioni (spese, zona, servizi, punti forti).
3) Piano visite concentrato: poche visite ma qualificate.

Risultato? Pi√π richieste, pi√π competizione, e trattativa pi√π semplice.
Se vuoi, scrivimi ‚ÄúCHECK‚Äù e ti dico cosa sistemare prima di pubblicare.`
        },
        B:{
          hook:"Vuoi pi√π contatti dal tuo annuncio? Fai questi 3 step prima di pubblicare.",
          script:
`Step 1: Apri con un beneficio chiaro (non con ‚Äúvendo casa‚Ä¶‚Äù).
Esempio: ‚ÄúA 2 minuti dai servizi, luminoso, pronto da abitare‚Äù.

Step 2: Taglia tutto ci√≤ che non serve.
Metti solo: metratura, punti forti, spese, e 1 dettaglio che differenzia (terrazzo, box, vista).

Step 3: Chiudi con una CTA semplice.
‚ÄúScrivimi ‚ÄòPLAN‚Äô e ti mando la scheda completa + disponibilit√† visite‚Äù.

Questi 3 step aumentano qualit√† dei contatti e riducono perdite di tempo.
Provali oggi sul prossimo post.`
        },
        C:{
          hook:"Mito da sfatare: ‚ÄúBasta pubblicare ovunque e arrivano clienti‚Äù.",
          script:
`Pubblicare ovunque non basta. Se il messaggio √® generico, l‚Äôalgoritmo non ti aiuta.
Quello che conta √®: una promessa chiara + una prova + una CTA.

Promessa: cosa ottiene la persona?
Prova: un esempio reale (numeri, caso, prima/dopo).
CTA: cosa deve fare subito (scrivere una parola, cliccare, salvare).

Quando fai cos√¨, anche con pochi follower ottieni risultati.
Se vuoi, dimmi il tuo settore e ti scrivo un hook su misura.`
        }
      }[kind];
      if(!t) return;
      $("#questionInput").value=t.hook;
      $("#answerInput").value=t.script;
      state.hook=t.hook;
      state.script=t.script;
      ensureLoopLine();
      $("#answerInput").value=state.script;
      updateCounts();
      updateRecorderUITexts();
      showToast("Template caricato ‚úÖ","good");
    }
    $("#tplA").addEventListener("click",()=>applyTemplate("A"));
    $("#tplB").addEventListener("click",()=>applyTemplate("B"));
    $("#tplC").addEventListener("click",()=>applyTemplate("C"));

    /*****************************************************************
     * 8) Logo upload (IndexedDB persist) + ImageBitmap
     *****************************************************************/
    const logoInput=$("#logoInput");
    $("#logoBtn").addEventListener("click",()=>logoInput.click());
    $("#removeLogoBtn").addEventListener("click",async ()=>{
      state.logoBlob=null;
      state.logoBitmap=null;
      if(db) await idbDel("settings","logo").catch(()=>{});
      $("#logoStatus").textContent="Nessun logo";
      showToast("Logo rimosso","good");
    });
    logoInput.addEventListener("change",async (e)=>{
      const file=e.target.files && e.target.files[0];
      logoInput.value="";
      if(!file) return;
      try{
        if(db) await idbPut("settings","logo",file);
        state.logoBlob=file;
        await loadLogoBitmapFromBlob(file);
        $("#logoStatus").textContent=`Logo: ${file.name}`;
        showToast("Logo salvato ‚úÖ","good");
      }catch(err){
        console.error(err);
        showToast("Errore nel salvataggio del logo","bad");
      }
    });
    async function loadLogoBitmapFromBlob(blob){
      try{
        const bmp=await createImageBitmap(blob);
        state.logoBitmap=bmp;
        state.logoAspect=bmp.width/bmp.height;
      }catch(e){
        state.logoBitmap=null;
        state.logoAspect=1;
      }
    }

    /*****************************************************************
     * 9) Camera (getUserMedia)
     *****************************************************************/
    async function startCamera(){
      const v=$("#livePreview");
      if(state.stream && v.srcObject) return;
      state.cameraReady=false;
      $("#recStatus").textContent="Avvio camera‚Ä¶";
      try{
        const constraints={
          audio:true,
          video:{ facingMode:"user", width:{ideal:1280}, height:{ideal:720} }
        };
        const stream=await navigator.mediaDevices.getUserMedia(constraints);
        state.stream=stream;
        state.audioTrack=stream.getAudioTracks()[0]||null;

        v.srcObject=stream;
        v.muted=true;
        await v.play().catch(()=>{});

        await new Promise((resolve)=>{
          if(v.readyState>=2 && v.videoWidth>0) return resolve();
          const on=()=>{
            if(v.videoWidth>0){
              v.removeEventListener("loadedmetadata",on);
              v.removeEventListener("canplay",on);
              resolve();
            }
          };
          v.addEventListener("loadedmetadata",on);
          v.addEventListener("canplay",on);
        });

        state.cameraReady=true;
        $("#recStatus").textContent="Pronto. Sottotitolo karaoke sempre ON.";
      }catch(err){
        console.error(err);
        state.stream=null;
        state.cameraReady=false;
        $("#recStatus").textContent="Permesso camera negato o non disponibile.";
        showToast("Permesso camera/microfono necessario (solo https/localhost).","bad");
      }
    }

    /*****************************************************************
     * 10) Karaoke subtitles (teleprompter orizzontale)
     *     - Sempre ON nel recorder
     *     - Evidenzia parola per parola in automatico (timing = WPM)
     *****************************************************************/
    function tokenizeScript(text){
      // Keep punctuation with tokens for readability
      const cleaned=(text||"")
        .replace(/\s+/g," ")
        .trim();
      if(!cleaned) return [];
      // Split by spaces, preserve punctuation attached
      return cleaned.split(" ").filter(Boolean);
    }

    function rebuildKaraokeTokens(){
      const s=(state.script||"").trim();
      state.words=tokenizeScript(s);
      // keep index in range
      state.tokenIndex = clamp(state.tokenIndex, 0, Math.max(0, state.words.length-1));
      renderKaraokeUI(performance.now());
    }

    function startKaraokeUI(){
      if(state.karaokeRunning) return;
      state.karaokeRunning=true;
      state.karaokeStartTs = performance.now();
      // Reset to start when opening recorder (for ‚Äúeasy scanning‚Äù)
      state.tokenIndex=0;
      renderKaraokeUI(performance.now());
      const tick=(ts)=>{
        if(!state.karaokeRunning) return;
        // Always advance, even if not recording (requirement: play always ON)
        advanceKaraoke(ts);
        renderKaraokeUI(ts);
        state.uiRaf=requestAnimationFrame(tick);
      };
      state.uiRaf=requestAnimationFrame(tick);
    }

    function stopKaraokeUI(){
      state.karaokeRunning=false;
      if(state.uiRaf) cancelAnimationFrame(state.uiRaf);
      state.uiRaf=null;
    }

    function advanceKaraoke(ts){
      if(!state.words.length) return;

      // words per second derived from WPM
      state.wps = state.wpm / 60;
      const elapsed = (ts - state.karaokeStartTs) / 1000;

      // One word step duration
      const step = 1 / Math.max(0.8, state.wps);

      // Determine current word index (karaoke highlight) based on elapsed
      // Loop continuously (no stop)
      const idx = Math.floor(elapsed / step) % state.words.length;
      state.tokenIndex = idx;
    }

    function getPhraseWindow(){
      const n = state.words.length;
      if(!n) return {start:0,end:0,idx:0};
      const idx = state.tokenIndex;
      const size = state.phraseSize;

      // Keep idx roughly centered in the phrase (but stable)
      const start = clamp(idx - Math.floor(size*0.35), 0, Math.max(0, n - size));
      const end = clamp(start + size, 0, n);
      return { start, end, idx };
    }

    function renderKaraokeUI(ts){
      const el=$("#subUiLine");
      if(!state.words.length){
        el.textContent="‚Äî";
        return;
      }
      const {start,end,idx} = getPhraseWindow();
      const parts=[];
      for(let i=start;i<end;i++){
        const w = state.words[i];
        const cls = (i===idx) ? "w on" : "w";
        // Use span: highlight current word
        parts.push(`<span class="${cls}">${escapeHtml(w)}</span>`);
      }
      el.innerHTML = parts.join(" ");
    }

    /*****************************************************************
     * 11) Recording pipeline: draw to canvas -> captureStream(30) + audio
     *****************************************************************/
    function chooseMimeType(){
      const c=[
        "video/webm;codecs=vp9,opus",
        "video/webm;codecs=vp8,opus",
        "video/webm"
      ];
      for(const t of c){
        if(window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(t)) return t;
      }
      return "";
    }

    function setupCanvas(){
      if(!state.canvas){
        state.canvas=document.createElement("canvas");
        state.ctx=state.canvas.getContext("2d",{alpha:false,desynchronized:true});
      }
      state.canvas.width=720;
      state.canvas.height=1280;
    }

    function drawCover(ctx, video, cw, ch, zoom=1.0){
      const vw=video.videoWidth||1280;
      const vh=video.videoHeight||720;
      const scale=Math.max(cw/vw, ch/vh) * zoom;
      const dw=vw*scale, dh=vh*scale;
      const dx=(cw-dw)/2, dy=(ch-dh)/2;
      ctx.drawImage(video, dx, dy, dw, dh);
    }

    function roundRect(ctx,x,y,w,h,r){
      const rr=Math.min(r,w/2,h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr,y);
      ctx.arcTo(x+w,y,x+w,y+h,rr);
      ctx.arcTo(x+w,y+h,x,y+h,rr);
      ctx.arcTo(x,y+h,x,y,rr);
      ctx.arcTo(x,y,x+w,y,rr);
      ctx.closePath();
    }

    function ellipsizeToWidth(ctx,str,maxW){
      if(ctx.measureText(str).width<=maxW) return str;
      const ell="‚Ä¶";
      let s=str;
      while(s.length>1 && ctx.measureText(s+ell).width>maxW) s=s.slice(0,-1);
      return s+ell;
    }

    function drawPill(ctx, text, x, y, maxW, fontPx, align="center"){
      ctx.save();
      ctx.font = `900 ${fontPx}px ${getComputedStyle(document.body).fontFamily}`;
      const padX=18, padY=10;
      const tw=ctx.measureText(text).width;
      const w=clamp(tw+padX*2, 0, maxW);
      const h=fontPx+padY*2;
      let rx=x;
      if(align==="center") rx=x-w/2;
      if(align==="right") rx=x-w;

      ctx.fillStyle="rgba(0,0,0,0.38)";
      ctx.strokeStyle="rgba(255,255,255,0.14)";
      ctx.lineWidth=2;
      roundRect(ctx, rx, y, w, h, 999);
      ctx.fill(); ctx.stroke();

      ctx.fillStyle="rgba(255,255,255,0.95)";
      ctx.textBaseline="middle";
      ctx.textAlign=align;
      const tx = align==="center" ? x : (align==="right" ? x : rx+padX);
      ctx.fillText(ellipsizeToWidth(ctx, text, w-padX*2), tx, y+h/2);
      ctx.restore();
    }

    function drawRecIcon(ctx, x, y, size){
      ctx.save();
      ctx.translate(x,y);
      ctx.fillStyle="rgba(255,45,85,0.95)";
      ctx.beginPath();
      ctx.arc(0,0,size/2,0,Math.PI*2);
      ctx.fill();
      const sq=size*0.34;
      ctx.fillStyle="rgba(255,255,255,0.92)";
      roundRect(ctx, -sq/2, -sq/2, sq, sq, Math.max(3,sq*0.18));
      ctx.fill();
      ctx.restore();
    }

    function drawLogo(ctx, cw){
      if(!state.logoBitmap) return;
      const margin=26;
      const targetW=cw*0.18;
      const w=targetW;
      const h=w/state.logoAspect;
      const x=cw - margin - w;
      const y=margin;
      ctx.save();
      ctx.fillStyle="rgba(0,0,0,0.25)";
      ctx.strokeStyle="rgba(255,255,255,0.12)";
      ctx.lineWidth=2;
      roundRect(ctx, x-10, y-10, w+20, h+20, 16);
      ctx.fill(); ctx.stroke();
      ctx.drawImage(state.logoBitmap, x, y, w, h);
      ctx.restore();
    }

    function drawKaraokeBurnIn(ctx, cw, ch){
      // Subtitle strip bottom (horizontal, readable)
      const pad=22;
      const h=92;
      const x=pad, y=ch - pad - h;
      const w=cw - pad*2;

      ctx.save();
      // background
      ctx.fillStyle="rgba(0,0,0,0.46)";
      ctx.strokeStyle="rgba(255,255,255,0.14)";
      ctx.lineWidth=2;
      roundRect(ctx, x, y, w, h, 20);
      ctx.fill(); ctx.stroke();

      // get phrase window + highlight current word
      if(!state.words.length){
        ctx.restore();
        return;
      }

      const {start,end,idx}=getPhraseWindow();
      const fontPx=Math.round(30 * state.tpZoom);
      ctx.font = `950 ${fontPx}px ${getComputedStyle(document.body).fontFamily}`;
      ctx.textAlign="center";
      ctx.textBaseline="middle";
      ctx.shadowColor="rgba(0,0,0,0.55)";
      ctx.shadowBlur=16;

      // Build text layout manually (centered tokens, current highlighted)
      // We‚Äôll measure each token to center the whole phrase.
      const tokens=[];
      for(let i=start;i<end;i++){
        tokens.push({text: state.words[i], on: i===idx});
      }

      // measure widths
      const spaceW = ctx.measureText(" ").width;
      const widths = tokens.map(t=>ctx.measureText(t.text).width);
      const totalW = widths.reduce((a,b)=>a+b,0) + spaceW*(tokens.length-1);

      // If too wide, reduce phrase size by trimming ends (hard clamp)
      // (keeps it readable on small screens)
      let trimmed=tokens, trimmedW=totalW;
      while(trimmed.length>4 && trimmedW > w - 24){
        // drop one from the far end (prefer drop from start/end away from highlight)
        const highlightIdx = trimmed.findIndex(t=>t.on);
        const dropFromStart = highlightIdx > (trimmed.length/2);
        trimmed = dropFromStart ? trimmed.slice(1) : trimmed.slice(0,-1);
        const tw = trimmed.map(t=>ctx.measureText(t.text).width).reduce((a,b)=>a+b,0);
        trimmedW = tw + spaceW*(trimmed.length-1);
      }

      const cx = x + w/2;
      const cy = y + h/2;
      let cursorX = cx - trimmedW/2;

      // draw tokens
      for(let i=0;i<trimmed.length;i++){
        const t=trimmed[i];
        const ww=ctx.measureText(t.text).width;

        if(t.on){
          // highlight box behind word (karaoke)
          const rx = cursorX - 6;
          const ry = cy - fontPx/2 - 8;
          const rw = ww + 12;
          const rh = fontPx + 16;

          ctx.save();
          ctx.shadowBlur=0;
          ctx.fillStyle="rgba(255,204,0,0.92)";
          roundRect(ctx, rx, ry, rw, rh, 14);
          ctx.fill();
          ctx.restore();

          ctx.fillStyle="rgba(0,0,0,0.92)";
          ctx.fillText(t.text, cursorX + ww/2, cy);
          ctx.fillStyle="rgba(255,255,255,0.92)";
        }else{
          ctx.fillStyle="rgba(255,255,255,0.92)";
          ctx.fillText(t.text, cursorX + ww/2, cy);
        }

        cursorX += ww + spaceW;
      }

      ctx.restore();
    }

    function renderFrame(ts){
      const ctx=state.ctx;
      const c=state.canvas;
      const v=$("#livePreview");
      if(!ctx || !c || !v) return;

      const cw=c.width, ch=c.height;
      state.lastFrameTs = ts;

      // background
      ctx.fillStyle="#000";
      ctx.fillRect(0,0,cw,ch);

      // video cover with zoom
      if(v.videoWidth>0) drawCover(ctx, v, cw, ch, state.tpZoom);

      // Hook burn-in from second 0
      const hook=(state.hook||"").trim();
      if(hook) drawPill(ctx, hook, cw/2, 22, cw*0.94, 28, "center");

      // Logo burn-in
      drawLogo(ctx, cw);

      // Karaoke burn-in (horizontal subtitles)
      drawKaraokeBurnIn(ctx, cw, ch);

      // REC burn-in while recording
      if(state.recording){
        drawRecIcon(ctx, cw - 42, 52, 30);
        ctx.save();
        ctx.font = `900 20px ${getComputedStyle(document.body).fontFamily}`;
        ctx.fillStyle="rgba(255,255,255,0.92)";
        ctx.textAlign="right";
        ctx.textBaseline="middle";
        ctx.shadowColor="rgba(0,0,0,0.55)";
        ctx.shadowBlur=12;
        ctx.fillText("REC", cw - 70, 52);
        ctx.restore();
      }

      state.rafId=requestAnimationFrame(renderFrame);
    }

    async function runCountdown(){
      const cd=$("#countdown");
      const n=$("#countNum");
      cd.classList.add("show");
      for(const v of [3,2,1]){
        n.textContent=v;
        await sleep(700);
      }
      cd.classList.remove("show");
    }

    async function startRecording(){
      if(state.recording) return;
      if(!canStartRec()) return;

      ensureLoopLine();
      $("#answerInput").value=state.script;
      updateRecorderUITexts();

      if(COUNTDOWN_ON) await runCountdown();

      // Reset karaoke timing so highlight starts from first word at REC
      state.karaokeStartTs = performance.now();
      state.tokenIndex = 0;

      setupCanvas();
      state.lastFrameTs=0;

      if(state.rafId) cancelAnimationFrame(state.rafId);
      state.rafId=requestAnimationFrame(renderFrame);

      const streamOut=state.canvas.captureStream(30);
      if(state.audioTrack){
        try{ streamOut.addTrack(state.audioTrack); }catch(e){}
      }

      const mimeType=chooseMimeType();
      let mr=null;
      try{
        mr = mimeType ? new MediaRecorder(streamOut,{mimeType}) : new MediaRecorder(streamOut);
      }catch(err){
        console.error(err);
        showToast("MediaRecorder non disponibile in questo browser.","bad");
        return;
      }

      state.recorder=mr;
      state.chunks=[];
      state.recording=true;
      state.recordStartTs=performance.now();

      $("#recBtn").classList.add("recording");
      $("#recHud").classList.add("on");
      $("#recStatus").textContent="Registrazione‚Ä¶ (max 60s)";
      $("#timeLeft").textContent=`${MAX_SECONDS}s`;

      mr.ondataavailable=(e)=>{ if(e.data && e.data.size>0) state.chunks.push(e.data); };
      mr.onstop=async ()=>{
        try{
          const blob=new Blob(state.chunks,{type: mr.mimeType || "video/webm"});
          state.recordedBlob=blob;
          state.chunks=[];
          await openReview(blob);
        }catch(e){
          console.error(e);
          showToast("Errore nel salvataggio del video","bad");
        }
      };

      mr.start(250);
      clearTimeout(state.stopTimer);
      state.stopTimer=setTimeout(()=>stopRecording(), MAX_SECONDS*1000);
      tickTimeLeft();
    }

    function tickTimeLeft(){
      if(!state.recording) return;
      const elapsed=(performance.now()-state.recordStartTs)/1000;
      const left=Math.max(0,Math.ceil(MAX_SECONDS-elapsed));
      $("#timeLeft").textContent=`${left}s`;
      if(left<=0) return;
      requestAnimationFrame(tickTimeLeft);
    }

    function stopRecording(){
      if(!state.recording) return;
      state.recording=false;
      clearTimeout(state.stopTimer);
      state.stopTimer=null;

      $("#recBtn").classList.remove("recording");
      $("#recHud").classList.remove("on");
      $("#recStatus").textContent="Pronto. Sottotitolo karaoke sempre ON.";
      $("#timeLeft").textContent=`${MAX_SECONDS}s`;

      try{ state.recorder && state.recorder.state!=="inactive" && state.recorder.stop(); }catch(e){}

      setTimeout(()=>{
        if(state.rafId){
          cancelAnimationFrame(state.rafId);
          state.rafId=null;
        }
      },120);
    }

    /*****************************************************************
     * 12) Review modal (save / download / discard)
     *****************************************************************/
    const reviewModal=$("#reviewModal");
    const reviewVideo=$("#reviewVideo");
    const reviewMeta=$("#reviewMeta");
    let reviewUrl=null;

    async function openReview(blob){
      buildCaption();
      const hook=(state.hook||"").trim();
      const tags=DEFAULT_TAGS.slice(0,5).join(" ");

      if(reviewUrl) URL.revokeObjectURL(reviewUrl);
      reviewUrl=URL.createObjectURL(blob);
      reviewVideo.src=reviewUrl;
      reviewVideo.loop=true;
      reviewVideo.play().catch(()=>{});

      reviewMeta.textContent=`Titolo: ${hook||"‚Äî"}\nHashtag: ${tags}\n\nCaption:\n${state.caption}`;

      reviewModal.classList.add("show");
      reviewModal.setAttribute("aria-hidden","false");
    }
    function closeReview(){
      reviewModal.classList.remove("show");
      reviewModal.setAttribute("aria-hidden","true");
      reviewVideo.pause();
    }
    $("#closeReviewBtn").addEventListener("click",closeReview);
    $("#discardClipBtn").addEventListener("click",()=>{
      state.recordedBlob=null;
      closeReview();
      showToast("Clip scartata","good");
    });
    $("#downloadClipBtn").addEventListener("click",()=>{
      if(!state.recordedBlob) return;
      const ts=new Date();
      const name=`clip_${ts.toISOString().replace(/[:.]/g,"-")}.webm`;
      downloadBlob(state.recordedBlob,name);
    });
    $("#saveClipBtn").addEventListener("click",async ()=>{
      if(!state.recordedBlob) return;
      const hook=(state.hook||"").trim();
      const hashtags=DEFAULT_TAGS.slice(0,5);
      buildCaption();
      const clip={ title:hook, caption:state.caption, hashtags, blob:state.recordedBlob, createdAt:Date.now() };
      try{
        await idbAddClip(clip);
        showToast("Salvato nel feed ‚úÖ","good");
        closeReview();
        state.recordedBlob=null;
        await renderFeed();
        setTab("feed");
      }catch(e){
        console.error(e);
        showToast("Errore nel salvataggio in archivio","bad");
      }
    });

    /*****************************************************************
     * 13) Feed (autoplay visible)
     *****************************************************************/
    const feedList=$("#feedList");
    let feedObserver=null;

    async function renderFeed(){
      const clips=(await idbGetAllClips()).sort((a,b)=>(b.createdAt||0)-(a.createdAt||0));
      if(feedObserver){ feedObserver.disconnect(); feedObserver=null; }
      feedList.innerHTML="";

      if(!clips.length){
        const empty=document.createElement("div");
        empty.className="empty";
        empty.innerHTML=`<div><div class="big">Nessun video salvato</div><div>Registra un clip nel Recorder e salvalo qui. üëá</div></div>`;
        feedList.appendChild(empty);
        return;
      }

      clips.forEach((clip)=>{
        const item=document.createElement("div");
        item.className="feedItem";
        item.dataset.id=clip.id;

        const url=URL.createObjectURL(clip.blob);
        item.dataset.url=url;

        const vid=document.createElement("video");
        vid.src=url;
        vid.playsInline=true;
        vid.loop=true;
        vid.muted=true;
        vid.preload="metadata";

        const meta=document.createElement("div");
        meta.className="feedMeta";
        const tagsStr=(clip.hashtags||[]).join(" ");
        meta.innerHTML=`
          <div class="pill">
            <div style="min-width:0;">
              <div class="title">${escapeHtml(clip.title||"‚Äî")}</div>
              <div class="tags">${escapeHtml(tagsStr)}</div>
            </div>
          </div>
        `;

        const actions=document.createElement("div");
        actions.className="feedActions";
        actions.innerHTML=`
          <div class="fab" data-act="download" title="Download">‚¨áÔ∏è<br><small>DL</small></div>
          <div class="fab" data-act="delete" title="Elimina">üóëÔ∏è<br><small>DEL</small></div>
        `;
        actions.addEventListener("click",async (e)=>{
          const btn=e.target.closest("[data-act]");
          if(!btn) return;
          const act=btn.dataset.act;
          if(act==="download") downloadBlob(clip.blob,`clip_${clip.id}.webm`);
          if(act==="delete") await deleteClip(clip.id);
        });

        item.appendChild(vid);
        item.appendChild(meta);
        item.appendChild(actions);
        feedList.appendChild(item);
      });

      const vids=$$(".feedItem video");
      feedObserver=new IntersectionObserver((entries)=>{
        entries.forEach((en)=>{
          const v=en.target;
          if(en.isIntersecting && en.intersectionRatio>=0.65){
            vids.forEach(o=>{ if(o!==v) o.pause(); });
            v.play().catch(()=>{});
          }else v.pause();
        });
      },{ root:feedList, threshold:[0,.35,.65,.9] });
      vids.forEach(v=>feedObserver.observe(v));
    }

    async function deleteClip(id){
      try{
        await idbDel("clips",id);
        showToast("Eliminato","good");
        await renderFeed();
      }catch(e){
        console.error(e);
        showToast("Errore eliminazione","bad");
      }
    }

    $("#wipeAllBtn").addEventListener("click",async ()=>{
      try{
        const clips=await idbGetAllClips();
        const tx=db.transaction("clips","readwrite");
        const st=tx.objectStore("clips");
        await Promise.all(clips.map(c=>new Promise((res,rej)=>{
          const r=st.delete(c.id);
          r.onsuccess=()=>res(true);
          r.onerror=()=>rej(r.error);
        })));
        showToast("Archivio svuotato","good");
        await renderFeed();
      }catch(e){
        console.error(e);
        showToast("Errore nello svuotamento","bad");
      }
    });

    /*****************************************************************
     * 14) Script builder wiring
     *****************************************************************/
    function updateCounts(){
      $("#qCount").textContent=`${($("#questionInput").value||"").trim().length}`;
      $("#aCount").textContent=`${($("#answerInput").value||"").trim().length}`;
    }
    $("#questionInput").addEventListener("input",()=>{
      state.hook=$("#questionInput").value.trim();
      updateCounts();
      updateRecorderUITexts();
    });
    $("#answerInput").addEventListener("input",()=>{
      state.script=$("#answerInput").value;
      updateCounts();
      updateRecorderUITexts();
    });

    $("#sendQuestionBtn").addEventListener("click",()=>{
      const q=$("#questionInput").value.trim();
      if(!q){
        showToast("Scrivi la domanda (hook) prima di inviare.","bad");
        $("#questionInput").focus(); return;
      }
      state.hook=q;
      updateRecorderUITexts();
      showOverlay("DOMANDA (Hook)",q);
      showToast("Domanda inviata in overlay","good");
    });

    $("#sendAnswerBtn").addEventListener("click",()=>{
      const a=$("#answerInput").value.trim();
      if(!a){
        showToast("Scrivi la risposta (script) prima di inviare.","bad");
        $("#answerInput").focus(); return;
      }
      state.script=$("#answerInput").value;
      ensureLoopLine();
      $("#answerInput").value=state.script;
      updateCounts();
      updateRecorderUITexts();
      showOverlay("RISPOSTA (Script)",state.script);
      showToast("Risposta inviata in overlay","good");
    });

    $("#pushToTeleprompterBtn").addEventListener("click",()=>{
      const q=$("#questionInput").value.trim();
      const a=$("#answerInput").value.trim();
      if(!q){ showToast("Manca la domanda (hook).","bad"); $("#questionInput").focus(); return; }
      if(!a){ showToast("Manca la risposta (script).","bad"); $("#answerInput").focus(); return; }
      state.hook=q;
      state.script=$("#answerInput").value;
      ensureLoopLine();
      $("#answerInput").value=state.script;
      updateCounts();
      updateRecorderUITexts();
      showToast("Caricato nel teleprompter ‚úÖ","good");
    });

    $("#copyCaptionBtn").addEventListener("click",async ()=>{
      buildCaption();
      try{ await navigator.clipboard.writeText(state.caption); showToast("Caption copiata ‚úÖ","good"); }
      catch(e){ showToast("Clipboard non disponibile","bad"); }
    });

    $("#goRecorderBtn").addEventListener("click",openRecorder);

    /*****************************************************************
     * 15) Recorder controls (sliders, REC, nav)
     *****************************************************************/
    $("#zoomRange").addEventListener("input",()=>{
      state.tpZoom=parseFloat($("#zoomRange").value);
      $("#zoomVal").textContent=`${state.tpZoom.toFixed(2)}√ó`;
    });
    $("#speedRange").addEventListener("input",()=>{
      state.wpm=parseFloat($("#speedRange").value);
      $("#spdVal").textContent=`${Math.round(state.wpm)} wpm`;
    });

    $("#recBtn").addEventListener("click",async ()=>{
      if(state.recording) stopRecording();
      else await startRecording();
    });

    $("#backToScriptBtn").addEventListener("click",openScript);
    $("#openFeedBtn").addEventListener("click",openFeed);
    $("#feedToRecBtn").addEventListener("click",openRecorder);

    $("#tabScript").addEventListener("click",openScript);
    $("#tabRec").addEventListener("click",openRecorder);
    $("#tabFeed").addEventListener("click",openFeed);

    /*****************************************************************
     * 16) Boot
     *****************************************************************/
    function escapeHtml(s){
      return (s||"").replace(/[&<>"']/g,(c)=>({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"}[c]));
    }

    async function boot(){
      if(!(location.protocol==="https:" || location.hostname==="localhost" || location.hostname==="127.0.0.1")){
        showToast("Nota: camera funziona solo su https/localhost.","bad");
      }
      try{
        db=await openDB();
      }catch(e){
        console.error(e);
        showToast("IndexedDB non disponibile: logo/feed non persistono.","bad");
      }

      // restore logo
      if(db){
        const savedLogo=await idbGet("settings","logo").catch(()=>null);
        if(savedLogo){
          state.logoBlob=savedLogo;
          await loadLogoBitmapFromBlob(savedLogo);
          $("#logoStatus").textContent="Logo caricato (persistente)";
        }else{
          $("#logoStatus").textContent="Nessun logo";
        }
      }

      updateCounts();
      buildCaption();
      updateRecorderUITexts();

      document.addEventListener("visibilitychange",()=>{
        if(document.hidden){
          try{ $("#reviewVideo").pause(); }catch(e){}
        }
      });
    }
    boot();
  </script>
</body>
</html>
