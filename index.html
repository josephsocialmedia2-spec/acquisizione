<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Archivio Domande → Estrai → ChatGPT</title>
  <style>
    :root{
      --bg:#0b0f17; --panel:#111827; --panel2:#0f172a; --text:#e5e7eb;
      --muted:#9ca3af; --line:#1f2937; --accent:#60a5fa; --accent2:#34d399;
      --warn:#fbbf24; --danger:#f87171;
      --radius:14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Liberation Sans", sans-serif;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:var(--sans); color:var(--text); background: radial-gradient(1200px 700px at 10% 10%, #0b2a5b33, transparent), var(--bg);
    }
    header{
      padding:22px 16px; border-bottom:1px solid var(--line);
      position:sticky; top:0; background:linear-gradient(180deg, rgba(11,15,23,.95), rgba(11,15,23,.72));
      backdrop-filter: blur(10px);
      z-index: 2;
    }
    .wrap{max-width:1100px; margin:0 auto}
    h1{margin:0 0 6px; font-size:18px; letter-spacing:.2px}
    .sub{color:var(--muted); font-size:13px; line-height:1.45}
    main{padding:16px}
    .grid{
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap:14px;
    }
    @media (max-width: 980px){
      .grid{grid-template-columns:1fr}
      header{position:static}
    }
    .card{
      background:linear-gradient(180deg, rgba(17,24,39,.95), rgba(15,23,42,.85));
      border:1px solid var(--line);
      border-radius:var(--radius);
      padding:14px;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .row > *{flex:0 0 auto}
    .spacer{flex:1 1 auto}
    label{font-size:12px; color:var(--muted); display:block; margin-bottom:6px}
    input[type="file"], input[type="text"], select, textarea{
      width:100%; border-radius:12px; border:1px solid var(--line);
      background:rgba(3,7,18,.35); color:var(--text); padding:10px 11px;
      outline:none;
    }
    textarea{min-height:140px; font-family:var(--mono); font-size:12px; line-height:1.35}
    .btn{
      border:1px solid var(--line); background: rgba(96,165,250,.15); color:var(--text);
      padding:10px 12px; border-radius:12px; cursor:pointer; font-weight:600;
      transition:.15s transform, .15s background, .15s border-color;
      user-select:none;
    }
    .btn:hover{transform: translateY(-1px); border-color: rgba(96,165,250,.45); background: rgba(96,165,250,.22)}
    .btn.secondary{background: rgba(52,211,153,.12)}
    .btn.secondary:hover{border-color: rgba(52,211,153,.55); background: rgba(52,211,153,.18)}
    .btn.warn{background: rgba(251,191,36,.12)}
    .btn.warn:hover{border-color: rgba(251,191,36,.55); background: rgba(251,191,36,.18)}
    .btn.danger{background: rgba(248,113,113,.12)}
    .btn.danger:hover{border-color: rgba(248,113,113,.55); background: rgba(248,113,113,.18)}
    .pill{
      font-size:12px; color:var(--muted); padding:6px 10px;
      border:1px solid var(--line); border-radius:999px; background:rgba(3,7,18,.25);
    }
    .list{
      display:flex; flex-direction:column; gap:10px; margin-top:10px;
      max-height:520px; overflow:auto; padding-right:4px;
    }
    .item{
      border:1px solid var(--line); border-radius:14px;
      background: rgba(3,7,18,.25);
      padding:10px;
      display:grid; gap:8px;
    }
    .itemTop{
      display:flex; gap:10px; align-items:center;
    }
    .item .title{font-weight:700; font-size:13px}
    .item .meta{font-size:12px; color:var(--muted)}
    .item pre{
      margin:0; padding:10px; border-radius:12px;
      background: rgba(17,24,39,.65); border:1px solid var(--line);
      white-space:pre-wrap; word-break:break-word;
      font-family:var(--mono); font-size:12px; line-height:1.35;
    }
    .small{font-size:12px; color:var(--muted)}
    .ok{color: var(--accent2)}
    .err{color: var(--danger)}
    .kbd{font-family:var(--mono); font-size:12px; padding:2px 6px; border:1px solid var(--line); border-radius:8px; background:rgba(3,7,18,.35)}
    .divider{height:1px; background:var(--line); margin:12px 0}
    .two{
      display:grid; grid-template-columns: 1fr 1fr; gap:10px;
    }
    @media (max-width:720px){ .two{grid-template-columns:1fr} }
    .hint{font-size:12px; color:var(--muted); line-height:1.45}
  </style>
</head>
<body>
<header>
  <div class="wrap">
    <h1>Archivio Domande → Estrai → ChatGPT</h1>
    <div class="sub">
      Carica un <span class="kbd">.csv</span> o <span class="kbd">.txt</span> (delimitatore <span class="kbd">;</span> o <span class="kbd">,</span>). Estrae le domande, te le fa cercare/filtrare e prepara un prompt pronto da incollare in ChatGPT.
    </div>
  </div>
</header>

<main class="wrap">
  <div class="grid">

    <!-- LEFT: ARCHIVIO + LISTA -->
    <section class="card">
      <div class="row">
        <div>
          <div style="font-weight:800; font-size:14px;">1) Archivio domande (upload)</div>
          <div class="small">Formato consigliato: <span class="kbd">area;Domanda;Risposta</span> (header opzionale)</div>
        </div>
        <div class="spacer"></div>
        <div class="pill" id="countPill">0 domande</div>
      </div>

      <div class="divider"></div>

      <div class="two">
        <div>
          <label for="fileInput">Carica file</label>
          <input id="fileInput" type="file" accept=".csv,.txt,text/plain,text/csv" />
          <div class="hint" style="margin-top:8px;">
            Se il file ha righe “strane”, usa il selettore delimitatore qui sotto.
          </div>
        </div>
        <div>
          <label for="delimiterSelect">Delimitatore</label>
          <select id="delimiterSelect">
            <option value="auto" selected>Auto (consigliato)</option>
            <option value=";">Punto e virgola ;</option>
            <option value=",">Virgola ,</option>
            <option value="\t">Tab</option>
          </select>

          <div style="margin-top:10px;">
            <label for="searchInput">Cerca (area / domanda / risposta)</label>
            <input id="searchInput" type="text" placeholder="es. trasparenza, prezzo troppo alto, documenti..." />
          </div>
        </div>
      </div>

      <div class="row" style="margin-top:12px;">
        <button class="btn" id="loadDemoBtn" type="button">Carica DEMO (dal testo incollato)</button>
        <button class="btn warn" id="clearBtn" type="button">Svuota</button>
        <div class="spacer"></div>
        <div class="small" id="statusLine">Nessun file caricato.</div>
      </div>

      <div class="list" id="resultsList" aria-live="polite"></div>
    </section>

    <!-- RIGHT: PROMPT + CHATGPT -->
    <aside class="card">
      <div style="font-weight:800; font-size:14px;">2) Prompt + ChatGPT</div>
      <div class="small">Step pratico: seleziona 1 domanda a sinistra → genera testo → apri ChatGPT → incolla.</div>

      <div class="divider"></div>

      <label for="promptBox">Prompt base (modificabile)</label>
      <textarea id="promptBox"></textarea>

      <div class="two" style="margin-top:10px;">
        <div>
          <label for="zoneInput">Zona</label>
          <input id="zoneInput" type="text" placeholder="[CITTÀ/PROVINCIA]" />
        </div>
        <div>
          <label for="targetInput">Target</label>
          <input id="targetInput" type="text" placeholder="[TARGET]" />
        </div>
      </div>

      <div class="two" style="margin-top:10px;">
        <div>
          <label for="tipoInput">Tipologia</label>
          <input id="tipoInput" type="text" placeholder="[TIPOLOGIA]" />
        </div>
        <div>
          <label for="canaliInput">Canali</label>
          <input id="canaliInput" type="text" placeholder="[CANALI]" />
        </div>
      </div>

      <div class="two" style="margin-top:10px;">
        <div>
          <label for="risorseInput">Risorse/tempo</label>
          <input id="risorseInput" type="text" placeholder="[RISORSE + MINUTI]" />
        </div>
        <div>
          <label for="uspInput">USP</label>
          <input id="uspInput" type="text" placeholder="[USP]" />
        </div>
      </div>

      <div class="divider"></div>

      <label for="finalBox">Testo finale (pronto da incollare)</label>
      <textarea id="finalBox" readonly></textarea>

      <div class="row" style="margin-top:10px;">
        <button class="btn secondary" id="buildBtn" type="button">Genera testo finale</button>
        <button class="btn" id="copyBtn" type="button">Copia negli appunti</button>
      </div>

      <div class="row" style="margin-top:10px;">
        <button class="btn" id="openChatBtn" type="button">Apri ChatGPT</button>
        <button class="btn secondary" id="openAndCopyBtn" type="button">Apri ChatGPT + Copia</button>
        <div class="spacer"></div>
        <span class="small">Poi: <span class="kbd">Ctrl/Cmd+V</span></span>
      </div>

      <div class="divider"></div>

      <div class="hint">
        <b>Extra</b>: se vuoi includere anche la <i>Risposta</i> dell’archivio, puoi selezionare “Includi risposta” nel box della domanda.
      </div>
    </aside>

  </div>
</main>

<script>
  // =========================
  // PROMPT (come richiesto)
  // =========================
  const BASE_PROMPT = `SEI UN ESPERTO DI ACQUISIZIONE IMMOBILIARE + VENDITA SUI SOCIAL (livello senior).
OBIETTIVO: costruire un sistema operativo completo per (1) acquisire incarichi immobiliari e (2) vendere immobili usando i social, con procedure giornaliere/settimanali e script pronti.
LINGUA: Italiano.
STILE: pratico, operativo, zero teoria. Frasi tipo “Fai questo → poi questo”.
VINCOLI:
- Non fare fuffa, non fare motivazione.
- Non inventare dati: se mancano info, fai assunzioni minime e dichiarale in 1 riga.
- Niente pratiche spam o contro regole piattaforme (no bot aggressivi, no DM a freddo di massa, no follow/unfollow).
- Nessuna discriminazione o targeting vietato (rispetta leggi e policy).
- Dove serve, inserisci “verifica conformità con norme locali/agenzia” senza fare consulenza legale.

INPUT (se non presenti, assumi valori standard e vai avanti):
- Zona: [CITTÀ/PROVINCIA]
- Target: [venditori privati | investitori | acquirenti prima casa | luxury | affitti]
- Tipologia immobili: [residenziale | commerciale | turistico]
- Canali: [Instagram, TikTok, Facebook, LinkedIn, YouTube Shorts]
- Risorse: [1 operatore | team] + tempo/die [minuti]
- USP agenzia: [es. home staging, virtual tour, banca dati, open house, mutui]

OUTPUT OBBLIGATORIO (non cambiare struttura):

1) POSIZIONAMENTO (1 pagina)
- Promessa chiara (1 frase)
- Perché fidarsi (3 prove: casi, metodo, trasparenza)
- Offerta “entry” non commerciale (es. valutazione, check-list, audit annuncio)
- Linee rosse: cosa NON prometti mai

2) SISTEMA DI ACQUISIZIONE INCARICHI (Venditori)
2.1 Dove trovare i proprietari (elenco canali + cosa fare)
- Commenti + post locali
- Gruppi Facebook di zona
- Community/associazioni/attività locali
- Hashtag e keyword reali (“vendo casa”, “valutazione”, “agenzia?”, “quanto vale”, “eredità”, “trasferimento”, ecc.)
- Competitor: commenti e post (senza attacchi)
2.2 Procedura “Non vendiamo, risolviamo” per aprire conversazione
- 10 domande aperte “da venditore” (capibili e umane)
- 10 segnali di urgenza (trasferimento, separazione, eredità, mutuo, tempi stretti, ecc.)
- Regola DM: solo dopo interazione (commento/risposta/like)

3) SISTEMA DI VENDITA IMMOBILI (Acquirenti)
3.1 Funnel social (scoperta → interesse → visita → proposta)
- Contenuti per attirare acquirenti (format)
- Contenuti per qualificare (domande, quiz, checklist)
- Call-to-action (DM “INFO”, form, WhatsApp, landing)
3.2 Procedura gestione richieste (SLA e follow-up)
- Tempi di risposta
- Script di qualificazione (budget, tempistiche, mutuo, zona, vincoli)
- Regole anti-perdita lead (tag, note, reminder)

4) CALENDARIO OPERATIVO (PRONTO)
4.1 Routine giornaliera (mattina / metà giornata / sera) — minuti, cosa fare, output atteso
- Acquisizione incarichi: ricerca → commento → like intelligente → DM (solo dopo) → registra lead
- Vendita immobili: risposte DM/commenti → follow-up → contenuti rapidi → storie
4.2 Routine settimanale (1x settimana)
- Revisione pipeline venditori (NUOVO/IN CONTATTO/APPUNTAMENTO/INCARICO/PERSO)
- Revisione pipeline acquirenti (NUOVO/QUALIFICATO/VISITA/PROPOSTA/CHIUSO)
- Aggiorna keyword/frasi reali + competitor + gruppi
- Pianifica contenuti (batch)
4.3 Routine mensile
- Report KPI minimi (contatti, appuntamenti, incarichi, visite, proposte)
- Miglioramenti (3 azioni)

5) SCRIPT COPIA/INCOLLA (PRONTI)
5.1 Commenti (apertura conversazione, non vendita) — 10 varianti
5.2 DM venditori (post-interazione) — 10 varianti
5.3 DM acquirenti (richiesta info immobile) — 10 varianti
5.4 Messaggi WhatsApp (se usato) — 6 varianti
5.5 Script telefonata breve (2 minuti) — venditore e acquirente
5.6 Obiezioni frequenti + risposte (commissione, “ci penso”, “ho già un’agenzia”, “voglio provare da solo”, “prezzo troppo alto”)

6) CONTENUTI: FORMATI + TEMPLATE
- 10 format acquisizione venditori (valutazione, errori, tempi, documenti, come preparare casa)
- 10 format vendita immobili (tour, quartiere, pro/contro, “prima casa”, “mutuo”, comparazioni)
- 10 format fiducia (dietro le quinte, testimonianze, open house, process)
Per ogni format: hook (1 frase), scaletta (3 punti), CTA (1), note riprese (1 riga)

7) PIPELINE E CRM “POVERO” (anche solo foglio)
- Campi minimi lead venditore + lead acquirente
- Stati + regole di passaggio
- Follow-up: T+1, T+3, T+7, T+14 (cosa inviare)

8) REGOLE DI QUALITÀ (non negoziabili)
- NO spam, NO link nei commenti, NO promesse false
- Trasparenza su prezzo/condizioni
- Privacy: cosa NON chiedere in pubblico
- Conformità: disclaimer dove serve

9) CHECKLIST “OGGI HO FATTO”
- 15 checkbox (acquisizione + vendita) con target numerici (es. 15 commenti utili, 5 DM post-interazione, 3 follow-up, 1 contenuto, 5 risposte rapide)

ADESSO PRODUCI L’OUTPUT COMPLETO seguendo questa struttura, adattato a:
Zona: [CITTÀ/PROVINCIA]
Target: [TARGET]
Tipologia: [TIPOLOGIA]
Canali: [CANALI]
Risorse/tempo: [RISORSE + MINUTI]
USP: [USP]`;

  // =========================
  // STATE
  // =========================
  let rows = []; // {area, domanda, risposta}
  let selectedIndex = null;

  // =========================
  // DOM
  // =========================
  const fileInput = document.getElementById('fileInput');
  const delimiterSelect = document.getElementById('delimiterSelect');
  const searchInput = document.getElementById('searchInput');
  const resultsList = document.getElementById('resultsList');
  const countPill = document.getElementById('countPill');
  const statusLine = document.getElementById('statusLine');

  const promptBox = document.getElementById('promptBox');
  const finalBox = document.getElementById('finalBox');

  const zoneInput = document.getElementById('zoneInput');
  const targetInput = document.getElementById('targetInput');
  const tipoInput = document.getElementById('tipoInput');
  const canaliInput = document.getElementById('canaliInput');
  const risorseInput = document.getElementById('risorseInput');
  const uspInput = document.getElementById('uspInput');

  const buildBtn = document.getElementById('buildBtn');
  const copyBtn = document.getElementById('copyBtn');
  const openChatBtn = document.getElementById('openChatBtn');
  const openAndCopyBtn = document.getElementById('openAndCopyBtn');

  const loadDemoBtn = document.getElementById('loadDemoBtn');
  const clearBtn = document.getElementById('clearBtn');

  // init
  promptBox.value = BASE_PROMPT;

  // =========================
  // HELPERS
  // =========================
  function detectDelimiter(text){
    const forced = delimiterSelect.value;
    if(forced !== 'auto') return forced === '\\t' ? '\t' : forced;

    // auto: count occurrences on first 20 non-empty lines
    const lines = text.split(/\r?\n/).filter(l => l.trim().length > 0).slice(0, 20);
    let semi = 0, comma = 0, tab = 0;
    for(const l of lines){
      semi += (l.match(/;/g)||[]).length;
      comma += (l.match(/,/g)||[]).length;
      tab += (l.match(/\t/g)||[]).length;
    }
    if(tab >= semi && tab >= comma && tab > 0) return '\t';
    if(semi >= comma && semi > 0) return ';';
    if(comma > 0) return ',';
    // fallback
    return ';';
  }

  function parseText(text){
    const delim = detectDelimiter(text);
    const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);

    // remove possible BOM
    if(lines.length && lines[0].charCodeAt(0) === 0xFEFF) lines[0] = lines[0].slice(1);

    const out = [];
    for(let i=0;i<lines.length;i++){
      const line = lines[i];
      // Skip separator lines
      if(!line || /^-+$/.test(line)) continue;

      const parts = line.split(delim).map(s => s.trim());
      // Header detect
      if(i===0){
        const lower = parts.map(p => p.toLowerCase());
        if(lower.includes('domanda') && (lower.includes('risposta') || lower.includes('area'))){
          continue; // skip header
        }
      }

      // Expected: area;Domanda;Risposta (but allow missing area)
      let area = '', domanda = '', risposta = '';
      if(parts.length >= 3){
        area = parts[0];
        domanda = parts[1];
        risposta = parts.slice(2).join(delim); // in case delim appears in risposta
      } else if(parts.length === 2){
        area = '';
        domanda = parts[0];
        risposta = parts[1];
      } else if(parts.length === 1){
        // try to salvage: whole line as domanda
        domanda = parts[0];
        risposta = '';
      }

      if(domanda.trim().length === 0) continue;
      out.push({ area, domanda, risposta });
    }
    return out;
  }

  function escapeHtml(str){
    return (str || '').replace(/[&<>"']/g, m => ({
      '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
    }[m]));
  }

  function updateCount(){
    countPill.textContent = `${rows.length} domande`;
  }

  function render(){
    const q = (searchInput.value || '').toLowerCase().trim();
    resultsList.innerHTML = '';

    const filtered = rows
      .map((r, idx) => ({...r, idx}))
      .filter(r => {
        if(!q) return true;
        return (r.area||'').toLowerCase().includes(q)
          || (r.domanda||'').toLowerCase().includes(q)
          || (r.risposta||'').toLowerCase().includes(q);
      });

    if(filtered.length === 0){
      resultsList.innerHTML = `<div class="small">Nessun risultato.</div>`;
      return;
    }

    for(const r of filtered){
      const isSel = (r.idx === selectedIndex);
      const el = document.createElement('div');
      el.className = 'item';

      el.innerHTML = `
        <div class="itemTop">
          <input type="radio" name="sel" ${isSel ? 'checked' : ''} aria-label="Seleziona domanda" />
          <div style="min-width:0">
            <div class="title">${escapeHtml(r.domanda)}</div>
            <div class="meta">
              ${r.area ? `Area: <b>${escapeHtml(r.area)}</b>` : `<span class="muted">Area: —</span>`}
              &nbsp;•&nbsp; ID: ${r.idx + 1}
            </div>
          </div>
          <div class="spacer"></div>
          <label class="pill" style="cursor:pointer;">
            <input type="checkbox" class="includeAnswer" data-idx="${r.idx}" style="margin-right:6px; transform: translateY(1px);" />
            Includi risposta
          </label>
        </div>
        <pre>${escapeHtml(r.risposta || '— (nessuna risposta in archivio)')}</pre>
        <div class="row">
          <button class="btn" type="button" data-action="copyQ" data-idx="${r.idx}">Copia domanda</button>
          <button class="btn secondary" type="button" data-action="useQ" data-idx="${r.idx}">Usa in prompt</button>
          <span class="small">Suggerito: “Usa in prompt” → “Apri ChatGPT + Copia”.</span>
        </div>
      `;

      // radio selection
      const radio = el.querySelector('input[type="radio"]');
      radio.addEventListener('change', () => {
        selectedIndex = r.idx;
        render();
      });

      // buttons
      el.querySelectorAll('button[data-action]').forEach(btn => {
        btn.addEventListener('click', async () => {
          const idx = Number(btn.getAttribute('data-idx'));
          const action = btn.getAttribute('data-action');
          if(action === 'copyQ'){
            await writeClipboard(rows[idx].domanda);
            toast(`Domanda copiata ✅`);
          }
          if(action === 'useQ'){
            selectedIndex = idx;
            buildFinal();
            toast(`Domanda inserita nel prompt ✅`);
            render();
          }
        });
      });

      resultsList.appendChild(el);
    }
  }

  function getSelectedIncludeAnswer(){
    if(selectedIndex === null) return false;
    const checkbox = document.querySelector(`.includeAnswer[data-idx="${selectedIndex}"]`);
    return checkbox ? checkbox.checked : false;
  }

  function applyPlaceholders(prompt){
    const rep = (txt, key, val) => txt.replaceAll(key, val && val.trim() ? val.trim() : key);

    let out = prompt;

    out = rep(out, '[CITTÀ/PROVINCIA]', zoneInput.value);
    out = rep(out, '[TARGET]', targetInput.value);
    out = rep(out, '[TIPOLOGIA]', tipoInput.value);
    out = rep(out, '[CANALI]', canaliInput.value);
    out = rep(out, '[RISORSE + MINUTI]', risorseInput.value);
    out = rep(out, '[USP]', uspInput.value);

    return out;
  }

  function buildFinal(){
    let base = promptBox.value || BASE_PROMPT;
    base = applyPlaceholders(base);

    let extra = '';
    if(selectedIndex !== null && rows[selectedIndex]){
      const r = rows[selectedIndex];
      const includeAnswer = getSelectedIncludeAnswer();

      extra += `\n\n---\nCONTESTO AGGIUNTIVO (dal mio archivio)\n`;
      if(r.area) extra += `Area: ${r.area}\n`;
      extra += `Domanda: ${r.domanda}\n`;
      if(includeAnswer && r.risposta) extra += `Risposta in archivio (se utile come base): ${r.risposta}\n`;
      extra += `---\n`;
    }

    finalBox.value = base + extra;
  }

  async function writeClipboard(text){
    try{
      await navigator.clipboard.writeText(text);
      return true;
    }catch(e){
      // fallback
      const ta = document.createElement('textarea');
      ta.value = text;
      document.body.appendChild(ta);
      ta.select();
      document.execCommand('copy');
      ta.remove();
      return true;
    }
  }

  function toast(msg){
    statusLine.innerHTML = `<span class="ok">${escapeHtml(msg)}</span>`;
    setTimeout(() => {
      statusLine.textContent = rows.length ? `Caricate ${rows.length} domande.` : `Nessun file caricato.`;
    }, 2200);
  }

  function setError(msg){
    statusLine.innerHTML = `<span class="err">${escapeHtml(msg)}</span>`;
  }

  // =========================
  // EVENTS
  // =========================
  fileInput.addEventListener('change', async (e) => {
    const f = e.target.files && e.target.files[0];
    if(!f) return;
    try{
      const text = await f.text();
      rows = parseText(text);
      selectedIndex = null;
      updateCount();
      render();
      statusLine.textContent = `Caricate ${rows.length} domande da "${f.name}".`;
      buildFinal();
    }catch(err){
      console.error(err);
      setError('Errore nel leggere/parsing del file.');
    }
  });

  delimiterSelect.addEventListener('change', () => {
    // re-parse only if we have an uploaded file in memory? Not stored.
    // Keep simple: tell user to re-upload or use DEMO
    toast('Delimitatore cambiato. Se hai già caricato un file, ricaricalo per riparsare.');
  });

  searchInput.addEventListener('input', render);

  buildBtn.addEventListener('click', () => {
    buildFinal();
    toast('Testo finale aggiornato ✅');
  });

  copyBtn.addEventListener('click', async () => {
    buildFinal();
    await writeClipboard(finalBox.value);
    toast('Testo finale copiato ✅');
  });

  openChatBtn.addEventListener('click', () => {
    window.open('https://chat.openai.com/', '_blank', 'noopener,noreferrer');
    toast('ChatGPT aperto (nuova scheda) ✅');
  });

  openAndCopyBtn.addEventListener('click', async () => {
    buildFinal();
    await writeClipboard(finalBox.value);
    window.open('https://chat.openai.com/', '_blank', 'noopener,noreferrer');
    toast('Copiato + ChatGPT aperto ✅');
  });

  clearBtn.addEventListener('click', () => {
    rows = [];
    selectedIndex = null;
    fileInput.value = '';
    searchInput.value = '';
    updateCount();
    render();
    finalBox.value = '';
    statusLine.textContent = 'Archivio svuotato.';
  });

  // DEMO: piccola base di esempio (incolla qui se vuoi)
  loadDemoBtn.addEventListener('click', () => {
    const demo = `area;Domanda;Risposta
Ecco cosa controllare prima di firmare un incarico.;Come capisco se un agente è davvero trasparente?;Trasparenza = dati + tempi + responsabilità chiare. Ti mostro analisi comparativa, piano marketing e report settimanale: così sai sempre cosa stiamo facendo e perché.
Se ti promettono tempi certi… attenzione.;Cosa mi dici se il mio prezzo è troppo alto?;Se il prezzo è fuori mercato te lo dico subito con comparabili e trend. Gonfiare il prezzo ti fa perdere domanda e potere negoziale: preferisco proteggere il tuo risultato.
Ecco cosa controllare prima di firmare un incarico.;Perché mi chiedi documenti prima ancora di pubblicare l’annuncio?;Per vendere bene serve partire puliti: documenti e conformità evitano blocchi in trattativa e sorprese al rogito. È un segnale di serietà, non burocrazia.`;
    rows = parseText(demo);
    selectedIndex = 0;
    updateCount();
    render();
    statusLine.textContent = `Caricate ${rows.length} domande (DEMO).`;
    buildFinal();
  });

  // initial render
  render();
  updateCount();
</script>
</body>
</html>
