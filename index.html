
/* ==========================
   CHATGPT INTEGRATION (NUOVA DOMANDA)
   - apre thread ChatGPT dedicato
   - copia negli appunti il prompt + la domanda
========================== */
const CHATGPT_THREAD_URL = 'https://chatgpt.com/c/695a2016-a020-8332-989d-4d3fada815fb';

function buildTeleprompterPrompt(questionText) {
  const q = String(questionText || '').trim();
  // Se non c'Ã¨ domanda, usa quella standard del prompt
  if (!q) return String(TELEPROMPTER_PROMPT || '').trim();
  return `${String(TELEPROMPTER_PROMPT || '').trim()}

DOMANDA:
${q}

ORA GENERA IL TESTO.`;
}

async function openChatGPTAndCopyPrompt() {
  // assicura che ci sia una domanda corrente
  if (!AppState.currentQuestion) {
    try { getNextQuestion(); } catch (e) {}
  }
  const payload = buildTeleprompterPrompt(AppState.currentQuestion);
  await copyToClipboard(payload);
  // apre la chat in una nuova scheda
  try {
    window.open(CHATGPT_THREAD_URL, '_blank', 'noopener');
  } catch (e) {
    // fallback: se popup bloccato, cambia location
    try { window.location.href = CHATGPT_THREAD_URL; } catch (_) {}
  }
  showToast('Prompt copiato. Apri ChatGPT e incolla (Ctrl+V).', 'success', 4500);
}


/* ==========================
   OVERRIDE: ORDINE COPIA (PROMPT â†’ DOMANDA)
========================== */
function buildTeleprompterPrompt(questionText) {
  const q = String(questionText || '').trim();
  const base = String(TELEPROMPTER_PROMPT || '').trim();
  if (!q) return base;
  // Ordine richiesto: prima PROMPT, poi DOMANDA generata (senza etichette aggiuntive)
  return `${base}

${q}`;
}




/* ==========================
   GLOBAL STATE & CONSTANTS
========================== */
'use strict';

const AppState = {
  // Question system
  questionBank: [
    "PerchÃ© ricevo poche chiamate anche se l'annuncio Ã¨ online da settimane?",
    "Se arrivano solo curiosi e nessuna proposta, cosa significa?",
    "Come capisco se il prezzo sta bloccando la vendita?",
    "Meglio partire alto e poi scendere o partire subito con il prezzo giusto?",
    "Ha senso provare a vendere da privato oppure rischio solo di perdere tempo?",
    "Se un agente mi chiede l'esclusiva, come capisco se conviene davvero?",
    "Quali sono le fasi reali di una vendita fatta bene, dall'inizio alla firma?",
    "Cosa devo controllare settimana per settimana per capire se la vendita sta andando bene?",
    "Se dopo le visite non succede nulla, qual Ã¨ la sequenza corretta per intervenire?"
  ],
  questionIndex: -1,
  currentQuestion: "",
  
  // Platform rotation
  rotation: ["tiktok", "instagram", "shorts", "facebook"],
  rotationIndex: 0,
  
  // Teleprompter
  teleSeconds: 105,
  teleRunning: false,
  teleStart: 0,
  teleRAF: null,
  
  // Camera & Recording
  camStream: null,
  canvasRAF: null,
  zoomValue: 1.1,
  
  // Recording state
  recorder: null,
  chunks: [],
  isRecording: false,
  recTimerId: null,
  recStartTs: null,
  
  // Video list
  videos: [],
  selectedVideoIndex: -1
};

/* ==========================
   DOM UTILITIES
========================== */
const $ = (id) => document.getElementById(id);
const $$ = (selector) => document.querySelectorAll(selector);

function showToast(message, type = 'info', duration = 3000) {
  const toast = document.createElement('div');
  toast.setAttribute('role', 'alert');
  toast.style.cssText = `
    position: fixed; top: 20px; right: 20px; z-index: 10000;
    padding: 12px 16px; border-radius: 12px; font-size: 13px;
    font-weight: 600; box-shadow: 0 8px 24px rgba(0,0,0,0.3);
    animation: slideIn 0.3s ease;
    max-width: 320px;
  `;
  
  if (type === 'success') {
    toast.style.background = 'linear-gradient(135deg, rgba(34,197,94,0.95), rgba(34,197,94,0.7))';
    toast.style.color = '#f0fdf4';
    toast.style.border = '1px solid rgba(34,197,94,0.5)';
  } else if (type === 'error') {
    toast.style.background = 'linear-gradient(135deg, rgba(239,68,68,0.95), rgba(239,68,68,0.7))';
    toast.style.color = '#fef2f2';
    toast.style.border = '1px solid rgba(239,68,68,0.5)';
  } else {
    toast.style.background = 'rgba(18,20,27,0.95)';
    toast.style.color = '#e9eef8';
    toast.style.border = '1px solid rgba(216,162,58,0.4)';
  }
  
  toast.textContent = message;
  document.body.appendChild(toast);
  
  setTimeout(() => {
    toast.style.animation = 'slideOut 0.3s ease';
    setTimeout(() => toast.remove(), 300);
  }, duration);
}

/* ==========================
   QUESTION MANAGEMENT
========================== */
function getNextQuestion() {
  AppState.questionIndex = (AppState.questionIndex + 1) % AppState.questionBank.length;
  AppState.currentQuestion = AppState.questionBank[AppState.questionIndex];
  $('qOverlay').textContent = AppState.currentQuestion;
  showToast('Nuova domanda caricata', 'success');
}

/* ==========================
   PROFILE ROTATION
========================== */
function refreshProfileDisplay() {
  if (!AppState.rotation.length) {
    $('profileNext').textContent = 'â€”';
    return;
  }
  AppState.rotationIndex = AppState.rotationIndex % AppState.rotation.length;
  $('profileNext').textContent = AppState.rotation[AppState.rotationIndex];
}

function advanceToNextProfile() {
  if (!AppState.rotation.length) return;
  AppState.rotationIndex = (AppState.rotationIndex + 1) % AppState.rotation.length;
  refreshProfileDisplay();
}

/* ==========================
   CLIPBOARD MANAGEMENT
========================== */
async function copyToClipboard(text) {
  const textToCopy = String(text || '').trim();
  if (!textToCopy) {
    showToast('Nessun testo da copiare', 'error');
    return false;
  }
  
  try {
    await navigator.clipboard.writeText(textToCopy);
    showToast('Copiato negli appunti', 'success');
    return true;
  } catch (err) {
    // Fallback per HTTP o browser vecchi
    try {
      const textArea = document.createElement('textarea');
      textArea.value = textToCopy;
      textArea.style.position = 'fixed';
      textArea.style.opacity = '0';
      document.body.appendChild(textArea);
      textArea.select();
      const success = document.execCommand('copy');
      textArea.remove();
      
      if (success) {
        showToast('Copiato negli appunti', 'success');
        return true;
      } else {
        throw new Error('Fallback copy failed');
      }
    } catch (fallbackErr) {
      showToast('Impossibile accedere agli appunti. Copia manualmente: ' + textToCopy.substring(0, 100), 'error');
      return false;
    }
  }
}

async function pasteFromClipboard() {
  try {
    const text = await navigator.clipboard.readText();
    if (text && $('answerBox')) {
      $('answerBox').value = text;
      showToast('Testo incollato dagli appunti', 'success');
      return text;
    }
  } catch (err) {
    // Fallback: usa prompt per incollare manualmente
    const fallbackText = prompt('Incolla il testo manualmente:');
    if (fallbackText && $('answerBox')) {
      $('answerBox').value = fallbackText;
      showToast('Testo incollato manualmente', 'info');
      return fallbackText;
    }
  }
  return '';
}

/* ==========================
   TELEPROMPTER SYSTEM
========================== */
function resetTeleprompter() {
  const teleText = $('teleText');
  if (teleText) {
    teleText.style.transform = 'translateY(20px)';
  }
}

function startTeleprompter() {
  if (AppState.teleRunning) return;
  
  AppState.teleRunning = true;
  AppState.teleStart = performance.now() / 1000;
  
  function tick() {
    if (!AppState.teleRunning) return;
    
    const teleText = $('teleText');
    if (!teleText) {
      AppState.teleRunning = false;
      return;
    }
    
    const now = performance.now() / 1000;
    const elapsed = now - AppState.teleStart;
    const progress = (elapsed % AppState.teleSeconds) / AppState.teleSeconds;
    
    const textHeight = teleText.scrollHeight || 900;
    const startY = 20;
    const endY = -textHeight - 40;
    const currentY = startY + (endY - startY) * progress;
    
    teleText.style.transform = `translateY(${currentY}px)`;
    AppState.teleRAF = requestAnimationFrame(tick);
  }
  
  AppState.teleRAF = requestAnimationFrame(tick);
}

function stopTeleprompter() {
  AppState.teleRunning = false;
  if (AppState.teleRAF) {
    cancelAnimationFrame(AppState.teleRAF);
    AppState.teleRAF = null;
  }
}

function restartTeleprompter() {
  stopTeleprompter();
  resetTeleprompter();
  setTimeout(startTeleprompter, 200);
}

function applyAnswerToTeleprompter(text) {
  const cleanText = String(text || '').trim();
  if (!cleanText) {
    showToast('Inserisci una risposta prima di inviare al teleprompter', 'error');
    return false;
  }
  
  const teleText = $('teleText');
  if (teleText) {
    teleText.textContent = cleanText;
    resetTeleprompter();
    stopTeleprompter();
    showToast('Risposta inviata al teleprompter', 'success');
    return true;
  }
  return false;
}

/* ==========================
   CAMERA & CANVAS SYSTEM
========================== */
const camera = {
  element: $('camPreview'),
  canvas: $('recCanvas'),
  context: null,
  
  init() {
    if (!this.canvas) return;
    this.context = this.canvas.getContext('2d', { 
      alpha: false,
      desynchronized: true 
    });
  },
  
  async start() {
    if (AppState.camStream) {
      this.stop();
    }
    
    try {
      AppState.camStream = await navigator.mediaDevices.getUserMedia({
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true
        },
        video: {
          facingMode: 'user',
          width: { ideal: 1280 },
          height: { ideal: 720 },
          frameRate: { ideal: 30 }
        }
      });
      
      this.element.srcObject = AppState.camStream;
      
      return new Promise((resolve, reject) => {
        this.element.onloadedmetadata = () => {
          this.element.play()
            .then(() => {
              this.startRenderLoop();
              showToast('Camera attivata', 'success');
              resolve(true);
            })
            .catch(reject);
        };
        this.element.onerror = reject;
      });
    } catch (error) {
      console.error('Camera error:', error);
      showToast(`Errore camera: ${error.message}`, 'error');
      return false;
    }
  },
  
  stop() {
    if (AppState.camStream) {
      AppState.camStream.getTracks().forEach(track => track.stop());
      AppState.camStream = null;
    }
    if (AppState.canvasRAF) {
      cancelAnimationFrame(AppState.canvasRAF);
      AppState.canvasRAF = null;
    }
  },
  
  startRenderLoop() {
    if (AppState.canvasRAF) return;
    
    const render = () => {
      if (!this.context || !this.element || this.element.readyState < 2) {
        AppState.canvasRAF = requestAnimationFrame(render);
        return;
      }
      
      const canvas = this.canvas;
      const video = this.element;
      
      if (video.videoWidth > 0 && video.videoHeight > 0) {
        const zoom = AppState.zoomValue;
        const srcWidth = video.videoWidth / zoom;
        const srcHeight = video.videoHeight / zoom;
        const srcX = (video.videoWidth - srcWidth) / 2;
        const srcY = (video.videoHeight - srcHeight) / 2;
        
        this.context.drawImage(
          video,
          srcX, srcY, srcWidth, srcHeight,
          0, 0, canvas.width, canvas.height
        );
      }
      
      AppState.canvasRAF = requestAnimationFrame(render);
    };
    
    AppState.canvasRAF = requestAnimationFrame(render);
  }
};

function updateZoom(value) {
  AppState.zoomValue = Math.max(1, Math.min(Number(value) || 1, 2.5));
  const zoomValElement = $('zoomVal');
  if (zoomValElement) {
    zoomValElement.textContent = AppState.zoomValue.toFixed(1) + 'Ã—';
  }
}

async function ensureCameraReady() {
  if (!AppState.camStream) {
    const success = await camera.start();
    if (!success) return false;
  }
  return true;
}

/* ==========================
   RECORDING SYSTEM
========================== */
const recording = {
  formatTime(ms) {
    const totalSeconds = Math.floor(ms / 1000);
    const minutes = String(Math.floor(totalSeconds / 60)).padStart(2, '0');
    const seconds = String(totalSeconds % 60).padStart(2, '0');
    return `${minutes}:${seconds}`;
  },
  
  updateUI(isRecording) {
    const dot = $('recDot');
    const label = $('recLabel');
    
    if (isRecording) {
      dot?.classList.add('rec');
      if (label) label.textContent = 'REC';
    } else {
      dot?.classList.remove('rec');
      if (label) label.textContent = 'PRONTO';
      $('recTime').textContent = '00:00';
    }
  },
  
  startTimer() {
    AppState.recStartTs = Date.now();
    $('recTime').textContent = '00:00';
    
    AppState.recTimerId = setInterval(() => {
      if (AppState.recStartTs) {
        $('recTime').textContent = this.formatTime(Date.now() - AppState.recStartTs);
      }
    }, 250);
  },
  
  stopTimer() {
    if (AppState.recTimerId) {
      clearInterval(AppState.recTimerId);
      AppState.recTimerId = null;
    }
    AppState.recStartTs = null;
  },
  
  generateTimestamp() {
    const now = new Date();
    const pad = (n) => String(n).padStart(2, '0');
    return `${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())}_${pad(now.getHours())}-${pad(now.getMinutes())}-${pad(now.getSeconds())}`;
  },
  
  async start() {
    // Validazione prerequisiti
    if (!AppState.camStream) {
      showToast('Attiva la camera prima di registrare', 'error');
      return;
    }
    
    if (AppState.recorder && AppState.recorder.state !== 'inactive') {
      showToast('Registrazione giÃ  in corso', 'error');
      return;
    }
    
    const answerText = ($('answerBox')?.value || '').trim();
    if (!answerText) {
      showToast('Scrivi o incolla una risposta prima di registrare', 'error');
      return;
    }
    
    // Inizia teleprompter
    applyAnswerToTeleprompter(answerText);
    startTeleprompter();
    
    // Prepara stream
    const canvasStream = camera.canvas.captureStream(30);
    const audioTrack = AppState.camStream.getAudioTracks()[0];
    if (audioTrack) {
      canvasStream.addTrack(audioTrack);
    }
    
    // Trova codec supportato
    const mimeOptions = [
      'video/webm;codecs=vp9,opus',
      'video/webm;codecs=vp8,opus',
      'video/webm;codecs=h264,opus',
      'video/webm'
    ];
    
    let mimeType = '';
    for (const option of mimeOptions) {
      if (MediaRecorder.isTypeSupported(option)) {
        mimeType = option;
        break;
      }
    }
    
    try {
      AppState.recorder = new MediaRecorder(canvasStream, mimeType ? { mimeType } : {});
      AppState.chunks = [];
      
      AppState.recorder.ondataavailable = (event) => {
        if (event.data && event.data.size > 0) {
          AppState.chunks.push(event.data);
        }
      };
      
      AppState.recorder.onstart = () => {
        AppState.isRecording = true;
        this.updateUI(true);
        this.startTimer();
        showToast('Registrazione iniziata', 'success');
      };
      
      AppState.recorder.onstop = () => {
        AppState.isRecording = false;
        this.updateUI(false);
        this.stopTimer();
        stopTeleprompter();
        
        if (AppState.chunks.length === 0) {
          showToast('Nessun dato registrato', 'error');
          return;
        }
        
        const blob = new Blob(AppState.chunks, { 
          type: AppState.recorder.mimeType || 'video/webm' 
        });
        
        const url = URL.createObjectURL(blob);
        const platform = AppState.rotation.length ? AppState.rotation[AppState.rotationIndex] : 'â€”';
        const timestamp = this.generateTimestamp();
        const title = `#${String(AppState.videos.length + 1).padStart(3, '0')} â€¢ ${platform} â€¢ ${timestamp}`;
        const filename = `video_${String(AppState.videos.length + 1).padStart(3, '0')}_${platform}_${timestamp}.webm`;
        
        AppState.videos.unshift({
          title,
          url,
          blob,
          filename,
          question: AppState.currentQuestion,
          platform,
          type: 'recorded',
          timestamp: new Date().toISOString()
        });
        
        AppState.selectedVideoIndex = 0;
        
        const player = $('player');
        if (player) {
          player.src = url;
          player.load();
        }
        
        renderVideoList();
        advanceToNextProfile();
        showToast('Registrazione completata', 'success');
      };
      
      AppState.recorder.onerror = (event) => {
        console.error('Recording error:', event.error);
        showToast(`Errore registrazione: ${event.error?.message || 'Unknown'}`, 'error');
        AppState.isRecording = false;
        this.updateUI(false);
        this.stopTimer();
        stopTeleprompter();
      };
      
      // Inizia registrazione
      AppState.recorder.start(1000); // Raccolta dati ogni secondo
      
    } catch (error) {
      console.error('Failed to start recording:', error);
      showToast(`Impossibile iniziare registrazione: ${error.message}`, 'error');
      stopTeleprompter();
    }
  },
  
  stop() {
    if (AppState.recorder && AppState.recorder.state === 'recording') {
      AppState.recorder.stop();
    }
  }
};

/* ==========================
   VIDEO LIST MANAGEMENT
========================== */
function renderVideoList() {
  const listElement = $('videoList');
  const totalCountElement = $('totalCount');
  const videoCountElement = $('videoCount');
  
  if (!listElement) return;
  
  // Aggiorna contatori
  if (totalCountElement) {
    totalCountElement.textContent = String(AppState.videos.length);
  }
  if (videoCountElement) {
    videoCountElement.textContent = `Video: ${AppState.videos.length}`;
  }
  
  // Render lista
  if (AppState.videos.length === 0) {
    listElement.innerHTML = `
      <div class="muted" role="listitem" style="text-align: center; padding: 20px;">
        â€” Nessun video ancora<br>
        <small>Registra o carica un video per iniziare</small>
      </div>
    `;
    return;
  }
  
  listElement.innerHTML = AppState.videos.map((video, index) => {
    const isSelected = index === AppState.selectedVideoIndex;
    const questionPreview = (video.question || '').substring(0, 100);
    const className = isSelected ? 'item selected' : 'item';
    const platformIcon = video.platform === 'tiktok' ? 'ðŸŽµ' : 
                        video.platform === 'instagram' ? 'ðŸ“·' : 
                        video.platform === 'facebook' ? 'ðŸ“˜' : 'ðŸŽ¬';
    
    return `
      <div class="${className}" 
           role="listitem" 
           data-index="${index}"
           aria-selected="${isSelected}"
           tabindex="0">
        <h3>${platformIcon} ${video.title}</h3>
        <div class="meta">
          <span class="k">${video.platform || 'â€”'}</span>
          <span class="k">${video.type === 'recorded' ? 'Registrato' : 'Caricato'}</span>
          <span class="k">${new Date(video.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</span>
        </div>
        <div class="muted" style="margin-top: 8px; font-size: 11px;">
          ${questionPreview}${video.question && video.question.length > 100 ? 'â€¦' : ''}
        </div>
      </div>
    `;
  }).join('');
  
  // Aggiungi event listeners
  listElement.querySelectorAll('[data-index]').forEach(item => {
    const index = parseInt(item.getAttribute('data-index'));
    
    item.addEventListener('click', () => {
      selectVideo(index);
    });
    
    item.addEventListener('keydown', (event) => {
      if (event.key === 'Enter' || event.key === ' ') {
        event.preventDefault();
        selectVideo(index);
      }
    });
  });
}

function selectVideo(index) {
  if (index < 0 || index >= AppState.videos.length) return;
  
  AppState.selectedVideoIndex = index;
  const video = AppState.videos[index];
  
  const player = $('player');
  if (player) {
    player.src = video.url;
    player.load();
    player.play().catch(() => {
      // Auto-play potrebbe essere bloccato, Ã¨ normale
    });
  }
  
  renderVideoList();
  showToast(`Video selezionato: ${video.title}`, 'info');
}

function downloadSelectedVideo() {
  if (AppState.selectedVideoIndex < 0 || !AppState.videos[AppState.selectedVideoIndex]) {
    showToast('Seleziona un video dalla lista prima di scaricare', 'error');
    return;
  }
  
  const video = AppState.videos[AppState.selectedVideoIndex];
  try {
    const url = URL.createObjectURL(video.blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = video.filename || `video_${Date.now()}.webm`;
    link.style.display = 'none';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    setTimeout(() => URL.revokeObjectURL(url), 1000);
    showToast(`Download avviato: ${video.filename}`, 'success');
  } catch (error) {
    console.error('Download error:', error);
    showToast(`Errore download: ${error.message}`, 'error');
  }
}

function handleFileUpload(file) {
  if (!file) return;
  
  if (!file.type.startsWith('video/')) {
    showToast('Seleziona un file video valido', 'error');
    return;
  }
  
  if (file.size > 500 * 1024 * 1024) { // 500MB limit
    showToast('File troppo grande (max 500MB)', 'error');
    return;
  }
  
  const url = URL.createObjectURL(file);
  const platform = AppState.rotation.length ? AppState.rotation[AppState.rotationIndex] : 'â€”';
  const title = `#${String(AppState.videos.length + 1).padStart(3, '0')} â€¢ ${platform} â€¢ UPLOAD â€¢ ${file.name.substring(0, 30)}`;
  
  AppState.videos.unshift({
    title,
    url,
    blob: file,
    filename: file.name,
    question: AppState.currentQuestion || 'Video caricato',
    platform,
    type: 'uploaded',
    timestamp: new Date().toISOString()
  });
  
  AppState.selectedVideoIndex = 0;
  
  const player = $('player');
  if (player) {
    player.src = url;
    player.load();
  }
  
  renderVideoList();
  advanceToNextProfile();
  showToast('Video caricato con successo', 'success');
}

function clearVideoList() {
  if (AppState.videos.length === 0) return;
  
  if (confirm(`Svuotare la lista video? (${AppState.videos.length} video)`)) {
    // Rilascia URL degli oggetti
    AppState.videos.forEach(video => {
      try {
        URL.revokeObjectURL(video.url);
      } catch (e) {
        // Ignora errori di URL giÃ  rilasciati
      }
    });
    
    AppState.videos = [];
    AppState.selectedVideoIndex = -1;
    
    const player = $('player');
    if (player) {
      player.removeAttribute('src');
      player.load();
    }
    
    AppState.rotationIndex = 0;
    refreshProfileDisplay();
    renderVideoList();
    showToast('Lista video svuotata', 'info');
  }
}

/* ==========================
   MODAL MANAGEMENT
========================== */
const modal = {
  element: $('modal'),
  
  show() {
    if (this.element) {
      this.element.hidden = false;
      this.element.style.display = 'flex';
      document.body.style.overflow = 'hidden';
      this.element.focus();
    }
  },
  
  hide() {
    if (this.element) {
      this.element.hidden = true;
      this.element.style.display = 'none';
      document.body.style.overflow = '';
    }
  },
  
  init() {
    const closeButton = $('btnCloseModal');
    if (closeButton) {
      closeButton.addEventListener('click', () => this.hide());
    }
    
    if (this.element) {
      this.element.addEventListener('click', (event) => {
        if (event.target === this.element) {
          this.hide();
        }
      });
      
      this.element.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
          this.hide();
        }
      });
    }
  }
};

/* ==========================
   INITIALIZATION
========================== */
function initApp() {
  // Verifica che il DOM sia completamente caricato
  if (document.readyState !== 'loading') {
    setupApp();
  } else {
    document.addEventListener('DOMContentLoaded', setupApp);
  }
}

function setupApp() {
  console.log('Initializing Video Creator App...');
  
  // Inizializza componenti
  camera.init();
  modal.init();
  
  // Stato iniziale
  refreshProfileDisplay();
  renderVideoList();
  
  // Setup zoom control
  const zoomSlider = $('zoom');
  if (zoomSlider) {
    updateZoom(zoomSlider.value);
    zoomSlider.addEventListener('input', (event) => {
      updateZoom(event.target.value);
    });
  }
  
  // Setup teleprompter speed
  const teleSpeedSelect = $('teleSpeed');
  if (teleSpeedSelect) {
    teleSpeedSelect.addEventListener('change', (event) => {
      AppState.teleSeconds = Number(event.target.value) || 105;
    });
  }
  
  // Setup profile rotation
  const profilesSelect = $('profiles');
  if (profilesSelect) {
    profilesSelect.addEventListener('change', (event) => {
      AppState.rotation = String(event.target.value || '')
        .split(',')
        .map(s => s.trim())
        .filter(Boolean);
      AppState.rotationIndex = 0;
      refreshProfileDisplay();
    });
  }
  
  // Setup bottoni
  setupEventListeners();
  
  // Controlla supporto MediaRecorder
  if (!window.MediaRecorder) {
    showToast('Il tuo browser non supporta la registrazione video. Aggiorna a una versione recente.', 'error');
  }
  
  // Controlla supporto getUserMedia
  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
    showToast('La fotocamera non Ã¨ supportata da questo browser', 'error');
  }
  
  console.log('App initialized successfully');
}

function setupEventListeners() {
  // Question buttons
  safeAddListener('btnNewQ', 'click', getNextQuestion);
  safeAddListener('btnCopyQuestion', 'click', async () => {
    if (!AppState.currentQuestion) {
      getNextQuestion();
    }
    await copyToClipboard(AppState.currentQuestion);
  });
  
  // Answer buttons
  safeAddListener('btnPasteAnswer', 'click', pasteFromClipboard);
  safeAddListener('btnSendTele', 'click', () => {
    const answerText = ($('answerBox')?.value || '').trim();
    applyAnswerToTeleprompter(answerText);
  });
  
  // Camera & recording buttons
  safeAddListener('btnCamera', 'click', () => ensureCameraReady());
  safeAddListener('btnTeleRec', 'click', async () => {
    if (!AppState.currentQuestion) {
      getNextQuestion();
    }
    
    const isReady = await ensureCameraReady();
    if (isReady) {
      recording.start();
    }
  });
  
  safeAddListener('btnStop', 'click', () => recording.stop());
  safeAddListener('btnRestartTele', 'click', () => restartTeleprompter());
  
  // Video list buttons
  safeAddListener('btnUpload', 'click', () => {
    $('fileInput')?.click();
  });
  
  safeAddListener('btnDownload', 'click', () => downloadSelectedVideo());
  safeAddListener('btnClear', 'click', () => clearVideoList());
  
  // Modal buttons
  safeAddListener('btnHelp', 'click', () => modal.show());
  
  // File input
  const fileInput = $('fileInput');
  if (fileInput) {
    fileInput.addEventListener('change', (event) => {
      const file = event.target.files?.[0];
      if (file) {
        handleFileUpload(file);
      }
      event.target.value = '';
    });
  }
  
  // Keyboard shortcuts
  document.addEventListener('keydown', (event) => {
    // Solo se non si sta scrivendo in un campo di testo
    if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
      return;
    }
    
    switch (event.key.toLowerCase()) {
      case 'f1':
        event.preventDefault();
        modal.show();
        break;
      case 'n':
        if (event.ctrlKey || event.metaKey) {
          event.preventDefault();
          getNextQuestion();
        }
        break;
      case 'r':
        if (event.ctrlKey || event.metaKey) {
          event.preventDefault();
          recording.start();
        }
        break;
      case 's':
        if (event.ctrlKey || event.metaKey) {
          event.preventDefault();
          recording.stop();
        }
        break;
    }
  });
  
  // Pulizia al ricaricamento
  window.addEventListener('beforeunload', () => {
    if (AppState.isRecording) {
      recording.stop();
    }
    camera.stop();
    
    // Rilascia URL degli oggetti
    AppState.videos.forEach(video => {
      try {
        URL.revokeObjectURL(video.url);
      } catch (e) {
        // Ignora errori
      }
    });
  });
  // Override "Nuova domanda": apre ChatGPT + copia prompt (in capture per bloccare handler precedente)
  const _btnNewQ = $('btnNewQ');
  if (_btnNewQ) {
    _btnNewQ.addEventListener('click', async (event) => {
      event.preventDefault();
      event.stopImmediatePropagation();
      await openChatGPTAndCopyPrompt();
    }, true);
  }

}

function safeAddListener(id, event, handler) {
  const element = $(id);
  if (element) {
    element.addEventListener(event, handler);
  } else {
    console.warn(`Element #${id} not found for event listener`);
  }
}

/* ==========================
   START APPLICATION
========================== */
// Inizializza app con ritardo per sicurezza
if (typeof requestIdleCallback !== 'undefined') {
  requestIdleCallback(() => initApp(), { timeout: 1000 });
} else {
  setTimeout(initApp, 100);
}

/* ==========================
   OVERRIDE: NUOVA DOMANDA â†’ APRI CHATGPT (LINK NUOVO) + COPIA PROMPT + COPIA DOMANDA
   Nota: per limiti di sicurezza del browser, l'incolla su ChatGPT non puÃ² essere automatico.
   Qui copiamo negli appunti: PROMPT (prima) + DOMANDA (dopo), in un unico contenuto.
========================== */
const CHATGPT_THREAD_URL_V2 = 'https://chatgpt.com/c/69588a96-4cdc-8332-91d2-26ac10ede496';

async function openChatGPTAndCopyPrompt() {
  // Genera SEMPRE una nuova domanda quando premi "Nuova domanda"
  try { getNextQuestion(); } catch (e) {}

  const payload = buildTeleprompterPrompt(AppState.currentQuestion);

  await copyToClipboard(payload);

  try {
    window.open(CHATGPT_THREAD_URL_V2, '_blank', 'noopener');
  } catch (e) {
    try { window.location.href = CHATGPT_THREAD_URL_V2; } catch (_) {}
  }

  showToast('Prompt copiato (prima) + domanda copiata (dopo). Incolla in ChatGPT (Ctrl+V).', 'success', 5200);
}

</script>

<!-- Aggiungi stili CSS per toast -->
<style>
@keyframes slideIn {
  from { transform: translateX(100%); opacity: 0; }
  to { transform: translateX(0); opacity: 1; }
}

@keyframes slideOut {
  from { transform: translateX(0); opacity: 1; }
  to { transform: translateX(100%); opacity: 0; }
}

/* Supporto per prefers-reduced-motion */
@media (prefers-reduced-motion: reduce) {
  @keyframes slideIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }
  
  @keyframes slideOut {
    from { opacity: 1; }
    to { opacity: 0; }
  }
}
</style>
</body>
</html>
