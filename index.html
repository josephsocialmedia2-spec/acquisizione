<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Vertical Recorder + Teleprompter (9:16)</title>
  <style>
    :root{
      --bg:#0b0c10;
      --panel:#12141a;
      --panel2:#0f1116;
      --text:#eef1ff;
      --muted:rgba(238,241,255,.72);
      --line:rgba(255,255,255,.10);
      --accent:#ff2d55;
      --good:#31d158;
      --warn:#ffcc00;
      --shadow: 0 18px 50px rgba(0,0,0,.45);
      --r:18px;
      --safeTop: env(safe-area-inset-top);
      --safeBottom: env(safe-area-inset-bottom);
      --safeLeft: env(safe-area-inset-left);
      --safeRight: env(safe-area-inset-right);
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; margin:0; background:var(--bg); color:var(--text); font-family:var(--font); }
    button,input,textarea{ font-family:inherit; }
    a{ color:inherit; }

    /* App shell */
    .app{
      height:100%;
      display:flex;
      flex-direction:column;
      padding: calc(10px + var(--safeTop)) calc(10px + var(--safeRight)) calc(10px + var(--safeBottom)) calc(10px + var(--safeLeft));
      gap:10px;
      overflow:hidden;
    }

    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 12px;
      background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.03));
      border:1px solid var(--line);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      flex: 0 0 auto;
    }
    .brand{
      display:flex; align-items:center; gap:10px;
      font-weight:800; letter-spacing:.2px;
    }
    .dot{
      width:10px; height:10px; border-radius:50%;
      background: var(--accent);
      box-shadow: 0 0 0 6px rgba(255,45,85,.14);
      flex:0 0 auto;
    }
    .tabs{
      display:flex; gap:8px;
    }
    .tab{
      border:1px solid var(--line);
      background: rgba(255,255,255,.04);
      color: var(--muted);
      padding:10px 12px;
      border-radius: 14px;
      font-weight:700;
      display:flex; align-items:center; gap:8px;
      user-select:none;
    }
    .tab.active{
      background: rgba(255,45,85,.12);
      border-color: rgba(255,45,85,.35);
      color: var(--text);
    }

    .screen{
      flex: 1 1 auto;
      min-height:0;
      display:none;
      overflow:hidden;
    }
    .screen.active{ display:block; }

    /* Common cards */
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--line);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card .hd{
      padding:12px 12px 0 12px;
      display:flex; justify-content:space-between; align-items:flex-start; gap:10px;
    }
    .card h2{
      margin:0;
      font-size:14px;
      letter-spacing:.2px;
      opacity:.95;
    }
    .hint{ color:var(--muted); font-size:12px; line-height:1.35; }
    .body{ padding:12px; }

    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap:10px;
    }
    @media (min-width: 920px){
      .grid.two{ grid-template-columns: 1.05fr .95fr; }
    }

    .field label{
      display:flex; justify-content:space-between; align-items:center;
      color: var(--muted);
      font-size:12px;
      margin: 0 0 6px 2px;
    }
    .field input, .field textarea{
      width:100%;
      border:1px solid var(--line);
      background: rgba(0,0,0,.25);
      color: var(--text);
      border-radius: 14px;
      padding: 12px 12px;
      font-size: 15px;
      outline:none;
    }
    .field textarea{ min-height: 140px; resize: vertical; }

    .row{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }

    .btn{
      appearance:none;
      border:1px solid var(--line);
      background: rgba(255,255,255,.05);
      color: var(--text);
      padding: 12px 14px;
      border-radius: 16px;
      font-weight: 800;
      letter-spacing:.2px;
      cursor:pointer;
      user-select:none;
      transition: transform .12s ease, background .12s ease, border-color .12s ease, opacity .12s ease;
    }
    .btn:active{ transform: scale(.98); }
    .btn.primary{
      background: rgba(255,45,85,.16);
      border-color: rgba(255,45,85,.35);
    }
    .btn.good{
      background: rgba(49,209,88,.14);
      border-color: rgba(49,209,88,.35);
    }
    .btn.warn{
      background: rgba(255,204,0,.12);
      border-color: rgba(255,204,0,.35);
    }
    .btn.ghost{
      background: transparent;
      border-color: var(--line);
      color: var(--muted);
      font-weight: 750;
    }
    .btn:disabled{
      opacity:.45;
      cursor:not-allowed;
      transform:none;
    }

    .templates{
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap:10px;
    }
    .templates .btn{
      padding: 14px 10px;
      border-radius: 18px;
      font-size: 14px;
    }

    /* Overlay (Domanda/Risposta preview) */
    .overlay{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px calc(18px + var(--safeRight)) calc(18px + var(--safeBottom)) calc(18px + var(--safeLeft));
      background: rgba(0,0,0,.62);
      backdrop-filter: blur(10px);
      z-index: 60;
    }
    .overlay.show{ display:flex; }
    .overlay .sheet{
      width:min(680px, 100%);
      background: rgba(18,20,26,.92);
      border:1px solid rgba(255,255,255,.16);
      border-radius: 22px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .sheet .sheet-hd{
      padding: 14px 14px 0 14px;
      display:flex; justify-content:space-between; align-items:center; gap:12px;
    }
    .sheet .sheet-hd .k{
      font-weight:900;
      letter-spacing:.2px;
    }
    .sheet .content{
      padding: 10px 14px 14px 14px;
      color: rgba(238,241,255,.9);
      line-height:1.45;
      font-size: 16px;
      white-space: pre-wrap;
      word-break: break-word;
    }

    /* Recorder layout */
    .recWrap{
      height:100%;
      display:grid;
      grid-template-rows: 1fr auto;
      gap: 10px;
      min-height:0;
    }
    .stage{
      position:relative;
      min-height:0;
      overflow:hidden;
      border-radius: 22px;
      border:1px solid var(--line);
      background: #000;
      box-shadow: var(--shadow);
      touch-action: manipulation;
    }

    .preview{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      object-fit: cover;
      transform: scaleX(-1); /* selfie preview mirror */
      background:#000;
    }

    /* 9:16 framing helper */
    .frame{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      pointer-events:none;
    }
    .frame::before{
      content:"";
      width: min(100%, calc(100vh * 9 / 16));
      height: min(100%, calc(100vw * 16 / 9));
      aspect-ratio: 9/16;
      border-radius: 26px;
      border:1px solid rgba(255,255,255,.12);
      box-shadow: inset 0 0 0 9999px rgba(0,0,0,.02);
    }

    /* Teleprompter overlay (UI) */
    .tpUi{
      position:absolute;
      left:50%;
      top: 18%;
      transform: translateX(-50%);
      width: min(92%, 560px);
      height: 58%;
      border-radius: 18px;
      background: rgba(0,0,0,.28);
      border: 1px solid rgba(255,255,255,.14);
      overflow:hidden;
      pointer-events:none;
      backdrop-filter: blur(6px);
    }
    .tpInner{
      position:absolute;
      left:0; right:0;
      top: 0;
      padding: 18px 18px 60px 18px;
      font-size: 28px;
      line-height: 1.28;
      font-weight: 800;
      text-align:center;
      color: rgba(255,255,255,.92);
      text-shadow: 0 2px 14px rgba(0,0,0,.55);
      white-space: pre-wrap;
      word-break: break-word;
      transform: translateY(0);
    }
    .tpFadeTop, .tpFadeBottom{
      position:absolute; left:0; right:0; height:62px; pointer-events:none;
      z-index:2;
    }
    .tpFadeTop{ top:0; background: linear-gradient(180deg, rgba(0,0,0,.62), rgba(0,0,0,0)); }
    .tpFadeBottom{ bottom:0; background: linear-gradient(0deg, rgba(0,0,0,.62), rgba(0,0,0,0)); }

    /* Hook burn-in UI label */
    .hookUi{
      position:absolute;
      top: 14px;
      left: 14px;
      right: 14px;
      display:flex;
      justify-content:center;
      pointer-events:none;
      z-index: 6;
    }
    .hookPill{
      max-width: 95%;
      padding: 10px 12px;
      border-radius: 999px;
      background: rgba(0,0,0,.36);
      border:1px solid rgba(255,255,255,.14);
      font-weight: 900;
      letter-spacing:.2px;
      text-align:center;
      text-shadow: 0 2px 12px rgba(0,0,0,.55);
      color: rgba(255,255,255,.95);
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }

    /* REC UI indicator */
    .recHud{
      position:absolute;
      top: 14px;
      right: 14px;
      display:flex;
      align-items:center;
      gap:8px;
      padding: 8px 10px;
      border-radius: 999px;
      background: rgba(0,0,0,.42);
      border:1px solid rgba(255,255,255,.14);
      z-index: 7;
      opacity: 0;
      transform: translateY(-6px);
      transition: opacity .16s ease, transform .16s ease;
      pointer-events:none;
    }
    .recHud.on{ opacity:1; transform: translateY(0); }
    .recBadge{
      width:10px; height:10px; border-radius:50%;
      background: var(--accent);
      box-shadow: 0 0 0 6px rgba(255,45,85,.16);
    }
    .recText{ font-weight: 900; letter-spacing:.6px; font-size: 12px; }

    /* Countdown overlay */
    .countdown{
      position:absolute;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      z-index: 10;
      background: rgba(0,0,0,.45);
      backdrop-filter: blur(6px);
    }
    .countdown.show{ display:flex; }
    .countdown .num{
      font-size: 92px;
      font-weight: 1000;
      letter-spacing: -2px;
      text-shadow: 0 10px 35px rgba(0,0,0,.6);
    }

    /* Controls strip under stage */
    .controls{
      display:grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }
    .controls .card{ padding: 10px 12px; }

    .tiny{
      font-size:12px; color: var(--muted);
    }

    .sliders{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      align-items:center;
    }
    .sliders .s{
      display:flex; flex-direction:column; gap:6px;
    }
    .sliders label{
      font-size:12px;
      color: var(--muted);
      display:flex; justify-content:space-between;
    }
    input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }

    /* REC big button */
    .recBtnWrap{
      display:flex;
      justify-content:center;
      padding: 6px 0;
    }
    .recBtn{
      width: 86px;
      height: 86px;
      border-radius: 999px;
      border: 2px solid rgba(255,255,255,.22);
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.12), rgba(255,255,255,.03) 60%, rgba(0,0,0,.12));
      display:grid;
      place-items:center;
      box-shadow: var(--shadow);
      cursor:pointer;
      user-select:none;
      position:relative;
      transition: transform .12s ease;
    }
    .recBtn:active{ transform: scale(.98); }
    .recCore{
      width: 62px;
      height: 62px;
      border-radius: 999px;
      background: var(--accent);
      display:grid;
      place-items:center;
      box-shadow: 0 12px 30px rgba(255,45,85,.25);
      border: 1px solid rgba(0,0,0,.25);
    }
    .stopSquare{
      width: 22px;
      height: 22px;
      border-radius: 5px;
      background: rgba(255,255,255,.92);
      transition: all .12s ease;
    }
    .recBtn.recording .recCore{
      background: rgba(255,45,85,.95);
      box-shadow: 0 16px 40px rgba(255,45,85,.35);
    }
    .recBtn.recording .stopSquare{
      width: 24px; height: 24px;
    }

    /* Feed */
    .feedWrap{
      height:100%;
      overflow:hidden;
      display:grid;
      grid-template-rows: auto 1fr;
      gap:10px;
      min-height:0;
    }
    .feedList{
      min-height:0;
      overflow:auto;
      scroll-snap-type: y mandatory;
      border-radius: 22px;
      border:1px solid var(--line);
      box-shadow: var(--shadow);
      background:#000;
    }
    .feedItem{
      position:relative;
      height: calc(100vh - 190px);
      min-height: 560px;
      scroll-snap-align: start;
      background:#000;
      border-bottom: 1px solid rgba(255,255,255,.08);
      overflow:hidden;
    }
    .feedItem video{
      position:absolute; inset:0;
      width:100%; height:100%;
      object-fit:cover;
      background:#000;
    }
    .feedMeta{
      position:absolute;
      left: 14px;
      right: 14px;
      bottom: 14px;
      z-index: 5;
      display:flex;
      flex-direction:column;
      gap:10px;
      pointer-events:none;
    }
    .feedMeta .pill{
      display:inline-flex;
      align-self:flex-start;
      gap:8px;
      align-items:center;
      padding: 10px 12px;
      border-radius: 18px;
      background: rgba(0,0,0,.42);
      border:1px solid rgba(255,255,255,.14);
      backdrop-filter: blur(8px);
      pointer-events:none;
      max-width: 100%;
    }
    .feedMeta .title{
      font-weight: 950;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }
    .feedMeta .tags{
      color: rgba(238,241,255,.8);
      font-size: 12px;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }
    .feedActions{
      position:absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      z-index: 6;
      display:flex;
      flex-direction:column;
      gap:10px;
      pointer-events:auto;
    }
    .fab{
      width: 52px; height: 52px;
      border-radius: 999px;
      display:grid; place-items:center;
      background: rgba(0,0,0,.42);
      border:1px solid rgba(255,255,255,.16);
      backdrop-filter: blur(8px);
      cursor:pointer;
      user-select:none;
      font-weight: 1000;
    }
    .fab:active{ transform: translateY(-50%) scale(.98); }
    .fab small{ font-size: 10px; opacity:.9; letter-spacing:.3px; }

    .empty{
      height:100%;
      display:grid;
      place-items:center;
      padding: 30px;
      color: var(--muted);
      text-align:center;
    }
    .empty .big{
      color: rgba(238,241,255,.92);
      font-weight: 950;
      font-size: 18px;
      margin-bottom: 6px;
    }

    /* Toast */
    .toasts{
      position: fixed;
      left: 0; right: 0;
      bottom: calc(12px + var(--safeBottom));
      display:flex;
      justify-content:center;
      pointer-events:none;
      z-index: 80;
      padding: 0 12px;
    }
    .toast{
      pointer-events:none;
      max-width: min(720px, 100%);
      background: rgba(18,20,26,.92);
      border:1px solid rgba(255,255,255,.16);
      border-radius: 18px;
      box-shadow: var(--shadow);
      padding: 12px 14px;
      display:flex;
      gap:10px;
      align-items:flex-start;
      transform: translateY(12px);
      opacity:0;
      transition: opacity .18s ease, transform .18s ease;
      backdrop-filter: blur(10px);
    }
    .toast.show{ opacity:1; transform: translateY(0); }
    .toast .icon{
      width: 10px; height: 10px; border-radius:50%;
      margin-top: 4px;
      background: var(--warn);
      box-shadow: 0 0 0 6px rgba(255,204,0,.16);
      flex:0 0 auto;
    }
    .toast.good .icon{ background: var(--good); box-shadow: 0 0 0 6px rgba(49,209,88,.16); }
    .toast.bad .icon{ background: var(--accent); box-shadow: 0 0 0 6px rgba(255,45,85,.16); }
    .toast .msg{
      font-size: 14px;
      line-height: 1.25;
      color: rgba(238,241,255,.92);
      word-break: break-word;
    }

    /* Review modal */
    .modal{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background: rgba(0,0,0,.62);
      backdrop-filter: blur(10px);
      padding: 18px calc(18px + var(--safeRight)) calc(18px + var(--safeBottom)) calc(18px + var(--safeLeft));
      z-index: 70;
    }
    .modal.show{ display:flex; }
    .modal .box{
      width: min(760px, 100%);
      background: rgba(18,20,26,.94);
      border:1px solid rgba(255,255,255,.16);
      border-radius: 22px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .modal .box .hd{
      padding: 14px 14px 10px 14px;
      display:flex; justify-content:space-between; align-items:center; gap:10px;
    }
    .modal .box .hd strong{ font-weight: 1000; }
    .modal .box .bd{
      padding: 0 14px 14px 14px;
      display:grid;
      gap: 12px;
    }
    .reviewVid{
      width:100%;
      aspect-ratio: 9/16;
      border-radius: 18px;
      border:1px solid rgba(255,255,255,.12);
      background:#000;
      object-fit:cover;
    }
    .modal .actions{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
    }
  </style>
</head>

<body>
  <div class="app">
    <div class="topbar">
      <div class="brand">
        <div class="dot"></div>
        <div>Vertical Recorder</div>
      </div>
      <div class="tabs">
        <button class="tab active" id="tabScript">Script</button>
        <button class="tab" id="tabRec">Recorder</button>
        <button class="tab" id="tabFeed">Feed</button>
      </div>
    </div>

    <!-- SCREEN: SCRIPT BUILDER (Domanda ‚Üí Risposta ‚Üí Overlay ‚Üí Teleprompter) -->
    <section class="screen active" id="screenScript">
      <div class="grid two" style="height:100%; min-height:0;">
        <div class="card" style="min-height:0; display:flex; flex-direction:column;">
          <div class="hd">
            <div>
              <h2>Flusso forzato: Domanda ‚Üí Risposta ‚Üí Invia al teleprompter</h2>
              <div class="hint">Scrivi la domanda (hook) e premi <b>INVIA</b>, poi chiudi l‚Äôoverlay. Poi fai lo stesso con la risposta (script) e invia al teleprompter.</div>
            </div>
          </div>
          <div class="body" style="min-height:0; overflow:auto;">
            <div class="grid">
              <div class="field">
                <label>Domanda (Hook) <span id="qCount">0</span></label>
                <textarea id="questionInput" placeholder="Esempio: Perch√© il 90% delle case resta invenduto per mesi?"></textarea>
              </div>
              <div class="row">
                <button class="btn primary" id="sendQuestionBtn">INVIA (Domanda)</button>
                <span class="tiny">La domanda appare in overlay. Poi devi chiuderlo.</span>
              </div>

              <div class="field">
                <label>Risposta (Script) <span id="aCount">0</span></label>
                <textarea id="answerInput" placeholder="Incolla o scrivi la risposta completa che vuoi leggere nel teleprompter..."></textarea>
              </div>
              <div class="row">
                <button class="btn primary" id="sendAnswerBtn">INVIA (Risposta)</button>
                <span class="tiny">Anche la risposta va vista in overlay e poi chiusa.</span>
              </div>

              <div class="row">
                <button class="btn good" id="pushToTeleprompterBtn">Invia al teleprompter</button>
                <button class="btn ghost" id="goRecorderBtn">Apri Recorder</button>
              </div>

              <div class="card" style="padding:12px;">
                <div class="row" style="justify-content:space-between;">
                  <div>
                    <div style="font-weight:950;">Caption standard (forzata)</div>
                    <div class="tiny">Hook + hashtag coerenti + firma fissa (non modificabile).</div>
                  </div>
                  <button class="btn ghost" id="copyCaptionBtn">Copia</button>
                </div>
                <div id="captionPreview" class="hint" style="margin-top:10px; white-space:pre-wrap;"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="card" style="min-height:0; display:flex; flex-direction:column;">
          <div class="hd">
            <div>
              <h2>Template rapidi (1 tap)</h2>
              <div class="hint">Riempiono Hook + Script e aggiungono una frase di <b>loop</b> (fine = inizio).</div>
            </div>
          </div>
          <div class="body" style="min-height:0; overflow:auto;">
            <div class="templates">
              <button class="btn" id="tplA">Errore comune</button>
              <button class="btn" id="tplB">3 Step</button>
              <button class="btn" id="tplC">Sfata un mito</button>
            </div>

            <div style="height:12px;"></div>

            <div class="card" style="padding:12px;">
              <div style="font-weight:950; margin-bottom:6px;">Logo (persistente)</div>
              <div class="hint" style="margin-bottom:10px;">Carica un logo: verr√† salvato in IndexedDB e burn-in nel video (in alto a destra).</div>
              <div class="row">
                <button class="btn" id="logoBtn">Carica logo</button>
                <button class="btn ghost" id="removeLogoBtn">Rimuovi</button>
                <span class="tiny" id="logoStatus">Nessun logo</span>
              </div>
            </div>

            <div style="height:12px;"></div>

            <div class="card" style="padding:12px;">
              <div style="font-weight:950; margin-bottom:6px;">Gate di registrazione (hard)</div>
              <div class="hint">
                Hook: <b>min 12</b> caratteri ¬∑ Script: <b>min 40</b> caratteri ¬∑ Countdown sempre ON ¬∑ Durata max <b>60s</b>.
              </div>
            </div>

          </div>
        </div>
      </div>
    </section>

    <!-- SCREEN: RECORDER -->
    <section class="screen" id="screenRecorder">
      <div class="recWrap">
        <div class="stage" id="stage">
          <video id="livePreview" class="preview" autoplay playsinline muted></video>

          <div class="hookUi">
            <div class="hookPill" id="hookUiText">Hook‚Ä¶</div>
          </div>

          <div class="recHud" id="recHud">
            <div class="recBadge"></div>
            <div class="recText">REC</div>
          </div>

          <div class="tpUi" aria-hidden="true">
            <div class="tpFadeTop"></div>
            <div class="tpFadeBottom"></div>
            <div class="tpInner" id="tpInner"></div>
          </div>

          <div class="countdown" id="countdown">
            <div class="num" id="countNum">3</div>
          </div>

          <div class="frame" aria-hidden="true"></div>
        </div>

        <div class="controls">
          <div class="card">
            <div class="sliders">
              <div class="s">
                <label>Zoom <span id="zoomVal">1.00√ó</span></label>
                <input id="zoomRange" type="range" min="1" max="1.35" step="0.01" value="1.00" />
              </div>
              <div class="s">
                <label>Velocit√† <span id="spdVal">70 px/s</span></label>
                <input id="speedRange" type="range" min="45" max="110" step="1" value="70" />
              </div>
            </div>
          </div>

          <div class="card">
            <div class="row" style="justify-content:space-between;">
              <div class="tiny" id="recStatus">Pronto. Teleprompter sempre ON.</div>
              <div class="tiny" id="timeLeft">60s</div>
            </div>
            <div class="recBtnWrap">
              <div class="recBtn" id="recBtn" role="button" aria-label="REC">
                <div class="recCore">
                  <div class="stopSquare"></div>
                </div>
              </div>
            </div>
            <div class="row" style="justify-content:space-between;">
              <button class="btn ghost" id="backToScriptBtn">‚Üê Script</button>
              <button class="btn ghost" id="openFeedBtn">Feed ‚Üí</button>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- SCREEN: FEED -->
    <section class="screen" id="screenFeed">
      <div class="feedWrap">
        <div class="card" style="padding:12px;">
          <div class="row" style="justify-content:space-between; align-items:flex-start;">
            <div>
              <div style="font-weight:950;">Archivio</div>
              <div class="hint">Scorri verticale. Autoplay solo del video visibile. Ogni clip: download / elimina.</div>
            </div>
            <div class="row">
              <button class="btn ghost" id="feedToRecBtn">‚Üê Recorder</button>
              <button class="btn warn" id="wipeAllBtn">Svuota</button>
            </div>
          </div>
        </div>

        <div class="feedList" id="feedList">
          <!-- items -->
        </div>
      </div>
    </section>

  </div>

  <!-- Overlay sheet (Domanda/Risposta) -->
  <div class="overlay" id="textOverlay" aria-hidden="true">
    <div class="sheet">
      <div class="sheet-hd">
        <div class="k" id="overlayTitle">Overlay</div>
        <button class="btn ghost" id="closeOverlayBtn">Chiudi</button>
      </div>
      <div class="content" id="overlayContent"></div>
    </div>
  </div>

  <!-- Review modal -->
  <div class="modal" id="reviewModal" aria-hidden="true">
    <div class="box">
      <div class="hd">
        <strong>Clip pronta</strong>
        <button class="btn ghost" id="closeReviewBtn">Chiudi</button>
      </div>
      <div class="bd">
        <video class="reviewVid" id="reviewVideo" controls playsinline></video>
        <div class="actions">
          <button class="btn good" id="saveClipBtn">Salva nel feed</button>
          <button class="btn primary" id="downloadClipBtn">Download</button>
          <button class="btn ghost" id="discardClipBtn">Scarta</button>
        </div>
        <div class="hint" id="reviewMeta"></div>
      </div>
    </div>
  </div>

  <!-- Toast container -->
  <div class="toasts" aria-live="polite" aria-atomic="true">
    <div class="toast" id="toast">
      <div class="icon"></div>
      <div class="msg" id="toastMsg">‚Äî</div>
    </div>
  </div>

  <!-- Hidden inputs -->
  <input id="logoInput" type="file" accept="image/*" hidden />

  <script>
    /*****************************************************************
     * 0) Tiny utilities (toast, sleep, download, formatting)
     *****************************************************************/
    const $ = (s)=>document.querySelector(s);
    const $$ = (s)=>Array.from(document.querySelectorAll(s));
    const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));

    const toastEl = $("#toast");
    const toastMsg = $("#toastMsg");
    let toastTimer = null;
    function showToast(msg, type="bad"){
      toastEl.classList.remove("good","bad");
      toastEl.classList.add(type);
      toastMsg.textContent = msg;
      toastEl.classList.add("show");
      clearTimeout(toastTimer);
      toastTimer = setTimeout(()=>toastEl.classList.remove("show"), 2200);
    }

    function downloadBlob(blob, filename){
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=>URL.revokeObjectURL(url), 1200);
    }

    function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

    /*****************************************************************
     * 1) IndexedDB (logo + clips)
     *****************************************************************/
    const DB_NAME = "vertical_recorder_db";
    const DB_VER = 1;
    let db = null;

    function openDB(){
      return new Promise((resolve, reject)=>{
        const req = indexedDB.open(DB_NAME, DB_VER);
        req.onupgradeneeded = (e)=>{
          const d = req.result;
          if(!d.objectStoreNames.contains("settings")){
            d.createObjectStore("settings");
          }
          if(!d.objectStoreNames.contains("clips")){
            const store = d.createObjectStore("clips", { keyPath:"id", autoIncrement:true });
            store.createIndex("createdAt", "createdAt");
          }
        };
        req.onsuccess = ()=>resolve(req.result);
        req.onerror = ()=>reject(req.error);
      });
    }

    function idbGet(store, key){
      return new Promise((resolve, reject)=>{
        const tx = db.transaction(store, "readonly");
        const st = tx.objectStore(store);
        const req = st.get(key);
        req.onsuccess = ()=>resolve(req.result);
        req.onerror = ()=>reject(req.error);
      });
    }

    function idbPut(store, key, value){
      return new Promise((resolve, reject)=>{
        const tx = db.transaction(store, "readwrite");
        const st = tx.objectStore(store);
        const req = st.put(value, key);
        req.onsuccess = ()=>resolve(true);
        req.onerror = ()=>reject(req.error);
      });
    }

    function idbDel(store, key){
      return new Promise((resolve, reject)=>{
        const tx = db.transaction(store, "readwrite");
        const st = tx.objectStore(store);
        const req = st.delete(key);
        req.onsuccess = ()=>resolve(true);
        req.onerror = ()=>reject(req.error);
      });
    }

    function idbAddClip(clip){
      return new Promise((resolve, reject)=>{
        const tx = db.transaction("clips", "readwrite");
        const st = tx.objectStore("clips");
        const req = st.add(clip);
        req.onsuccess = ()=>resolve(req.result);
        req.onerror = ()=>reject(req.error);
      });
    }

    function idbGetAllClips(){
      return new Promise((resolve, reject)=>{
        const tx = db.transaction("clips", "readonly");
        const st = tx.objectStore("clips");
        const req = st.getAll();
        req.onsuccess = ()=>resolve(req.result || []);
        req.onerror = ()=>reject(req.error);
      });
    }

    /*****************************************************************
     * 2) App state (script, caption, logo, teleprompter)
     *****************************************************************/
    const DEFAULT_TAGS = ["#immobiliare","#realestate","#marketing","#socialmedia","#content"]; // max 5 coerenti
    const FIXED_SIGNATURE =
`geometra Christian Raimondi
Immobiliare La Sacra

üìû 346 256 8685
üìß immobiliarelasacra@gmail.com`;

    const LOOP_PREFIX = "Se ti sei perso l‚Äôinizio, rivedilo:";
    const MAX_SECONDS = 60;
    const COUNTDOWN_ON = true; // hard-coded
    const TP_ALWAYS_ON = true; // hard-coded
    const TP_BURN_IN = true; // hard-coded

    const state = {
      hook: "",
      script: "",
      caption: "",
      logoBlob: null,
      logoBitmap: null, // ImageBitmap for draw
      logoAspect: 1,
      // Teleprompter
      tpScrollY: 0,
      tpLines: [],
      tpLineH: 40,
      tpFontPx: 30,
      tpSpeed: 70, // px/s default
      tpZoom: 1.0,
      // Recorder
      stream: null,
      cameraReady: false,
      recording: false,
      recorder: null,
      chunks: [],
      recordedBlob: null,
      recordStartTs: 0,
      stopTimer: null,
      // Canvas rendering
      canvas: null,
      ctx: null,
      rafId: null,
      lastFrameTs: 0,
      // Audio track reference
      audioTrack: null
    };

    function buildCaption(){
      const hook = (state.hook || "").trim();
      const tags = DEFAULT_TAGS.slice(0,5).join(" ");
      const firstLine = hook ? hook : "‚Äî";
      state.caption = `${firstLine}\n${tags}\n\n${FIXED_SIGNATURE}`;
      $("#captionPreview").textContent = state.caption;
    }

    function ensureLoopLine(){
      const hook = (state.hook || "").trim();
      if(!hook) return;
      const loopLine = `${LOOP_PREFIX} ${hook}`;
      const s = (state.script || "").trim();
      if(!s) return;
      // Add if missing (simple heuristic)
      if(!s.toLowerCase().includes(LOOP_PREFIX.toLowerCase())){
        state.script = s.replace(/\s+$/,"") + "\n\n" + loopLine;
      }
    }

    function updateRecorderUITexts(){
      $("#hookUiText").textContent = (state.hook || "Hook‚Ä¶").trim() || "Hook‚Ä¶";
      $("#tpInner").textContent = (state.script || "").trim() || "‚Äî";
      buildCaption();
    }

    // Gate rules (hard)
    function canStartRec(){
      const hook = (state.hook || "").trim();
      const script = (state.script || "").trim();
      if(hook.length < 12){
        showToast("Scrivi un hook chiaro (min 12 caratteri)", "bad");
        $("#questionInput").focus();
        return false;
      }
      if(script.length < 40){
        showToast("Scrivi uno script teleprompter (min 40 caratteri)", "bad");
        $("#answerInput").focus();
        return false;
      }
      // Camera ready rule:
      const v = $("#livePreview");
      if(!state.stream || !v.srcObject || !(v.videoWidth > 0)){
        showToast("Avvio camera‚Ä¶ concedi i permessi.", "bad");
        startCamera().catch(()=>{});
        return false;
      }
      return true;
    }

    /*****************************************************************
     * 3) Screen navigation
     *****************************************************************/
    const screens = {
      script: $("#screenScript"),
      recorder: $("#screenRecorder"),
      feed: $("#screenFeed"),
    };
    function setTab(active){
      $("#tabScript").classList.toggle("active", active==="script");
      $("#tabRec").classList.toggle("active", active==="recorder");
      $("#tabFeed").classList.toggle("active", active==="feed");
      Object.keys(screens).forEach(k=>{
        screens[k].classList.toggle("active", k===active);
      });
    }

    async function openRecorder(){
      setTab("recorder");
      // Teleprompter always ON when recorder is open
      if(TP_ALWAYS_ON){
        resetTeleprompter();
      }
      // Camera auto-start
      await startCamera().catch(()=>{});
      updateRecorderUITexts();
    }

    function openScript(){
      setTab("script");
      // Optionally keep camera running to avoid re-permission; but for UX we keep it.
    }

    async function openFeed(){
      setTab("feed");
      await renderFeed();
    }

    /*****************************************************************
     * 4) Overlay flow (Domanda/Risposta ‚Üí Overlay ‚Üí Chiudi)
     *****************************************************************/
    const overlay = $("#textOverlay");
    const overlayTitle = $("#overlayTitle");
    const overlayContent = $("#overlayContent");

    function showOverlay(title, text){
      overlayTitle.textContent = title;
      overlayContent.textContent = text;
      overlay.classList.add("show");
      overlay.setAttribute("aria-hidden","false");
    }
    function closeOverlay(){
      overlay.classList.remove("show");
      overlay.setAttribute("aria-hidden","true");
    }

    $("#closeOverlayBtn").addEventListener("click", closeOverlay);
    overlay.addEventListener("click", (e)=>{
      if(e.target === overlay) closeOverlay();
    });

    /*****************************************************************
     * 5) Templates (fill + add loop line)
     *****************************************************************/
    function applyTemplate(kind){
      // Concrete social/marketing examples (real estate flavored but generic enough)
      const t = {
        A: {
          hook: "L‚Äôerrore pi√π comune quando metti in vendita casa: puntare tutto sul prezzo.",
          script:
`Se vuoi vendere velocemente, il prezzo conta‚Ä¶ ma non √® l‚Äôunica leva.
L‚Äôerrore pi√π comune √® ‚Äútagliare‚Äù il prezzo senza sistemare il contesto.

Ecco cosa funziona meglio:
1) Foto e video che fanno percepire valore (luce, ordine, angoli giusti).
2) Descrizione che risponde alle obiezioni (spese, zona, servizi, punti forti).
3) Piano visite concentrato: poche visite ma qualificate.

Risultato? Pi√π richieste, pi√π competizione, e trattativa pi√π semplice.
Se vuoi, scrivimi ‚ÄúCHECK‚Äù e ti dico cosa sistemare prima di pubblicare.`
        },
        B: {
          hook: "Vuoi pi√π contatti dal tuo annuncio? Fai questi 3 step prima di pubblicare.",
          script:
`Step 1: Apri con un beneficio chiaro (non con ‚Äúvendo casa‚Ä¶‚Äù).
Esempio: ‚ÄúA 2 minuti dai servizi, luminoso, pronto da abitare‚Äù.

Step 2: Taglia tutto ci√≤ che non serve.
Metti solo: metratura, punti forti, spese, e 1 dettaglio che differenzia (terrazzo, box, vista).

Step 3: Chiudi con una CTA semplice.
‚ÄúScrivimi ‚ÄòPLAN‚Äô e ti mando la scheda completa + disponibilit√† visite‚Äù.

Questi 3 step aumentano qualit√† dei contatti e riducono perdite di tempo.
Provali oggi sul prossimo post.`
        },
        C: {
          hook: "Mito da sfatare: ‚ÄúBasta pubblicare ovunque e arrivano clienti‚Äù.",
          script:
`Pubblicare ovunque non basta. Se il messaggio √® generico, l‚Äôalgoritmo non ti aiuta.
Quello che conta √®: una promessa chiara + una prova + una CTA.

Promessa: cosa ottiene la persona?
Prova: un esempio reale (numeri, caso, prima/dopo).
CTA: cosa deve fare subito (scrivere una parola, cliccare, salvare).

Quando fai cos√¨, anche con pochi follower ottieni risultati.
Se vuoi, dimmi il tuo settore e ti scrivo un hook su misura.`
        }
      }[kind];

      if(!t) return;

      // Fill inputs + state
      $("#questionInput").value = t.hook;
      $("#answerInput").value = t.script;
      state.hook = t.hook;
      state.script = t.script;

      ensureLoopLine();
      $("#answerInput").value = state.script;

      updateCounts();
      updateRecorderUITexts();
      showToast("Template caricato ‚úÖ", "good");
    }

    $("#tplA").addEventListener("click", ()=>applyTemplate("A"));
    $("#tplB").addEventListener("click", ()=>applyTemplate("B"));
    $("#tplC").addEventListener("click", ()=>applyTemplate("C"));

    /*****************************************************************
     * 6) Logo upload (IndexedDB persist) + ImageBitmap for burn-in
     *****************************************************************/
    const logoInput = $("#logoInput");
    $("#logoBtn").addEventListener("click", ()=>logoInput.click());

    $("#removeLogoBtn").addEventListener("click", async ()=>{
      state.logoBlob = null;
      state.logoBitmap = null;
      await idbDel("settings","logo");
      $("#logoStatus").textContent = "Nessun logo";
      showToast("Logo rimosso", "good");
    });

    logoInput.addEventListener("change", async (e)=>{
      const file = e.target.files && e.target.files[0];
      logoInput.value = "";
      if(!file) return;
      try{
        await idbPut("settings","logo", file);
        state.logoBlob = file;
        await loadLogoBitmapFromBlob(file);
        $("#logoStatus").textContent = `Logo: ${file.name}`;
        showToast("Logo salvato ‚úÖ", "good");
      }catch(err){
        console.error(err);
        showToast("Errore nel salvataggio del logo", "bad");
      }
    });

    async function loadLogoBitmapFromBlob(blob){
      try{
        const bmp = await createImageBitmap(blob);
        state.logoBitmap = bmp;
        state.logoAspect = bmp.width / bmp.height;
      }catch(e){
        state.logoBitmap = null;
        state.logoAspect = 1;
      }
    }

    /*****************************************************************
     * 7) Camera: getUserMedia auto in Recorder (audio+user facing)
     *****************************************************************/
    async function startCamera(){
      // If already active and ready, skip
      const v = $("#livePreview");
      if(state.stream && v.srcObject){
        return;
      }
      state.cameraReady = false;
      $("#recStatus").textContent = "Avvio camera‚Ä¶";
      try{
        const constraints = {
          audio: true,
          video: {
            facingMode: "user",
            width: { ideal: 1280 },
            height:{ ideal: 720 }
          }
        };
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        state.stream = stream;
        state.audioTrack = stream.getAudioTracks()[0] || null;

        v.srcObject = stream;
        v.muted = true;
        await v.play().catch(()=>{});

        // Wait for metadata so videoWidth is available
        await new Promise((resolve)=>{
          if(v.readyState >= 2 && v.videoWidth > 0) return resolve();
          const on = ()=>{
            if(v.videoWidth > 0){
              v.removeEventListener("loadedmetadata", on);
              v.removeEventListener("canplay", on);
              resolve();
            }
          };
          v.addEventListener("loadedmetadata", on);
          v.addEventListener("canplay", on);
        });

        state.cameraReady = true;
        $("#recStatus").textContent = "Pronto. Teleprompter sempre ON.";
      }catch(err){
        console.error(err);
        state.stream = null;
        state.cameraReady = false;
        $("#recStatus").textContent = "Permesso camera negato o non disponibile.";
        showToast("Permesso camera/microfono necessario (solo https/localhost).", "bad");
      }
    }

    /*****************************************************************
     * 8) Teleprompter: auto-scroll always ON when recorder open
     *    - UI scrolls via transform
     *    - Burn-in draws wrapped lines on canvas (same scroll)
     *****************************************************************/
    function wrapTextToLines(ctx, text, maxWidth){
      const rawLines = (text || "").split("\n");
      const out = [];
      for(const ln of rawLines){
        const words = ln.split(/\s+/).filter(Boolean);
        if(words.length === 0){
          out.push("");
          continue;
        }
        let cur = words[0];
        for(let i=1;i<words.length;i++){
          const test = cur + " " + words[i];
          if(ctx.measureText(test).width <= maxWidth){
            cur = test;
          }else{
            out.push(cur);
            cur = words[i];
          }
        }
        out.push(cur);
      }
      return out;
    }

    function resetTeleprompter(){
      // reset scroll to start (off-screen bottom-ish)
      state.tpScrollY = 0;
      $("#tpInner").style.transform = `translateY(0px)`;
      // Rebuild later during rendering (needs canvas ctx too)
    }

    /*****************************************************************
     * 9) Recording pipeline: draw to canvas -> captureStream(30) + audio
     *****************************************************************/
    function chooseMimeType(){
      const candidates = [
        "video/webm;codecs=vp9,opus",
        "video/webm;codecs=vp8,opus",
        "video/webm"
      ];
      for(const t of candidates){
        if(window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(t)){
          return t;
        }
      }
      return ""; // generic fallback
    }

    function setupCanvas(){
      if(!state.canvas){
        state.canvas = document.createElement("canvas");
        state.ctx = state.canvas.getContext("2d", { alpha: false, desynchronized: true });
      }
      // Use a consistent vertical resolution (good balance)
      state.canvas.width = 720;
      state.canvas.height = 1280;
    }

    function drawCover(ctx, video, cw, ch, zoom=1.0){
      // cover draw with optional zoom (scale up)
      const vw = video.videoWidth || 1280;
      const vh = video.videoHeight || 720;

      const scale = Math.max(cw / vw, ch / vh) * zoom;
      const dw = vw * scale;
      const dh = vh * scale;

      const dx = (cw - dw) / 2;
      const dy = (ch - dh) / 2;

      ctx.drawImage(video, dx, dy, dw, dh);
    }

    function drawPill(ctx, text, x, y, maxW, fontPx, align="center"){
      ctx.save();
      ctx.font = `900 ${fontPx}px ${getComputedStyle(document.body).fontFamily}`;
      const padX = 18, padY = 10;
      const tw = ctx.measureText(text).width;
      const w = clamp(tw + padX*2, 0, maxW);
      const h = fontPx + padY*2;
      let rx = x;
      if(align === "center") rx = x - w/2;
      if(align === "right") rx = x - w;

      ctx.fillStyle = "rgba(0,0,0,0.38)";
      ctx.strokeStyle = "rgba(255,255,255,0.14)";
      ctx.lineWidth = 2;
      roundRect(ctx, rx, y, w, h, 999);
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.textBaseline = "middle";
      ctx.textAlign = align;
      const tx = align==="center" ? x : (align==="right" ? x : rx + padX);
      ctx.fillText(ellipsizeToWidth(ctx, text, w - padX*2), tx, y + h/2);
      ctx.restore();
    }

    function ellipsizeToWidth(ctx, str, maxW){
      if(ctx.measureText(str).width <= maxW) return str;
      const ell = "‚Ä¶";
      let s = str;
      while(s.length > 1 && ctx.measureText(s + ell).width > maxW){
        s = s.slice(0, -1);
      }
      return s + ell;
    }

    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    function drawRecIcon(ctx, x, y, size){
      // red circle + white square inside (burn-in)
      ctx.save();
      ctx.translate(x, y);
      ctx.fillStyle = "rgba(255,45,85,0.95)";
      ctx.beginPath();
      ctx.arc(0,0,size/2,0,Math.PI*2);
      ctx.fill();

      const sq = size*0.34;
      ctx.fillStyle = "rgba(255,255,255,0.92)";
      roundRect(ctx, -sq/2, -sq/2, sq, sq, Math.max(3, sq*0.18));
      ctx.fill();
      ctx.restore();
    }

    function drawLogo(ctx, cw, ch){
      if(!state.logoBitmap) return;
      // top-right, proportional size
      const margin = 26;
      const targetW = cw * 0.18; // ~18% width
      const w = targetW;
      const h = w / state.logoAspect;
      const x = cw - margin - w;
      const y = margin;
      ctx.save();
      // subtle backing
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      ctx.strokeStyle = "rgba(255,255,255,0.12)";
      ctx.lineWidth = 2;
      roundRect(ctx, x-10, y-10, w+20, h+20, 16);
      ctx.fill();
      ctx.stroke();
      ctx.drawImage(state.logoBitmap, x, y, w, h);
      ctx.restore();
    }

    function prepareTeleprompterLines(ctx, cw){
      const text = (state.script || "").trim() || "‚Äî";
      const boxW = cw * 0.86;
      const fontPx = Math.round(30 * state.tpZoom);
      const lineH = Math.round(fontPx * 1.34);

      ctx.save();
      ctx.font = `900 ${fontPx}px ${getComputedStyle(document.body).fontFamily}`;
      const lines = wrapTextToLines(ctx, text, boxW);
      ctx.restore();

      state.tpLines = lines;
      state.tpFontPx = fontPx;
      state.tpLineH = lineH;
    }

    function drawTeleprompterBurnIn(ctx, cw, ch, dt){
      if(!TP_BURN_IN) return;

      // Box position roughly center
      const boxW = cw * 0.88;
      const boxH = ch * 0.58;
      const boxX = (cw - boxW)/2;
      const boxY = ch * 0.18;

      // background
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.28)";
      ctx.strokeStyle = "rgba(255,255,255,0.14)";
      ctx.lineWidth = 2;
      roundRect(ctx, boxX, boxY, boxW, boxH, 22);
      ctx.fill();
      ctx.stroke();

      // fades
      const fadeH = 70;
      const topGrad = ctx.createLinearGradient(0, boxY, 0, boxY+fadeH);
      topGrad.addColorStop(0, "rgba(0,0,0,0.62)");
      topGrad.addColorStop(1, "rgba(0,0,0,0)");
      ctx.fillStyle = topGrad;
      ctx.fillRect(boxX, boxY, boxW, fadeH);

      const botGrad = ctx.createLinearGradient(0, boxY+boxH-fadeH, 0, boxY+boxH);
      botGrad.addColorStop(0, "rgba(0,0,0,0)");
      botGrad.addColorStop(1, "rgba(0,0,0,0.62)");
      ctx.fillStyle = botGrad;
      ctx.fillRect(boxX, boxY+boxH-fadeH, boxW, fadeH);

      // text
      if(state.tpLines.length === 0) prepareTeleprompterLines(ctx, cw);

      ctx.font = `900 ${state.tpFontPx}px ${getComputedStyle(document.body).fontFamily}`;
      ctx.fillStyle = "rgba(255,255,255,0.92)";
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.shadowColor = "rgba(0,0,0,0.55)";
      ctx.shadowBlur = 18;

      // Scroll calculation: continuous, never stops
      const speed = state.tpSpeed; // px/s
      state.tpScrollY -= speed * dt; // move upward

      // total text height
      const totalH = state.tpLines.length * state.tpLineH + 120;
      // reset (loop) when scrolled past end
      if(-state.tpScrollY > totalH){
        state.tpScrollY = boxH + 40; // start below visible area
      }

      const startY = boxY + 18 + state.tpScrollY;
      const centerX = boxX + boxW/2;

      // draw only visible lines
      const topClip = boxY + 10;
      const bottomClip = boxY + boxH - 10;

      for(let i=0;i<state.tpLines.length;i++){
        const y = startY + i * state.tpLineH;
        if(y > bottomClip) break;
        if(y + state.tpLineH < topClip) continue;
        ctx.fillText(state.tpLines[i], centerX, y);
      }

      ctx.restore();

      // Sync UI teleprompter overlay (so user sees same motion)
      // Keep it light: just transform once per frame.
      const ui = $("#tpInner");
      ui.style.fontSize = `${Math.round(28 * state.tpZoom)}px`;
      ui.style.transform = `translateY(${Math.round(state.tpScrollY)}px)`;
    }

    function renderFrame(ts){
      const ctx = state.ctx;
      const c = state.canvas;
      const v = $("#livePreview");
      if(!ctx || !c || !v) return;

      const cw = c.width, ch = c.height;

      const dt = state.lastFrameTs ? (ts - state.lastFrameTs)/1000 : 0;
      state.lastFrameTs = ts;

      // background
      ctx.fillStyle = "#000";
      ctx.fillRect(0,0,cw,ch);

      // video cover (with zoom)
      if(v.videoWidth > 0){
        drawCover(ctx, v, cw, ch, state.tpZoom);
      }

      // Hook pill burn-in (from second 0)
      const hook = (state.hook || "").trim();
      if(hook){
        drawPill(ctx, hook, cw/2, 22, cw*0.94, 28, "center");
      }

      // Logo burn-in (if present)
      drawLogo(ctx, cw, ch);

      // Teleprompter burn-in (always on in recorder)
      drawTeleprompterBurnIn(ctx, cw, ch, dt);

      // REC indicator burn-in while recording
      if(state.recording){
        drawRecIcon(ctx, cw - 42, 52, 30);
        // optional tiny "REC"
        ctx.save();
        ctx.font = `900 20px ${getComputedStyle(document.body).fontFamily}`;
        ctx.fillStyle = "rgba(255,255,255,0.92)";
        ctx.textAlign = "right";
        ctx.textBaseline = "middle";
        ctx.shadowColor = "rgba(0,0,0,0.55)";
        ctx.shadowBlur = 12;
        ctx.fillText("REC", cw - 70, 52);
        ctx.restore();
      }

      // Continue
      state.rafId = requestAnimationFrame(renderFrame);
    }

    async function runCountdown(){
      const cd = $("#countdown");
      const n = $("#countNum");
      cd.classList.add("show");
      for(const v of [3,2,1]){
        n.textContent = v;
        await sleep(700);
      }
      cd.classList.remove("show");
    }

    async function startRecording(){
      if(state.recording) return;

      // Hard gates
      if(!canStartRec()) return;

      // Ensure loop line exists
      ensureLoopLine();
      $("#answerInput").value = state.script;
      updateRecorderUITexts();

      // Countdown always ON
      if(COUNTDOWN_ON){
        await runCountdown();
      }

      // Setup canvas + start render
      setupCanvas();
      state.tpLines = [];
      state.tpScrollY = state.canvas.height * 0.58 + 40; // start below tp box
      state.lastFrameTs = 0;

      if(state.rafId) cancelAnimationFrame(state.rafId);
      state.rafId = requestAnimationFrame(renderFrame);

      // capture stream 30 fps
      const streamOut = state.canvas.captureStream(30);

      // add original audio track
      if(state.audioTrack){
        try{
          streamOut.addTrack(state.audioTrack);
        }catch(e){
          // ignore
        }
      }

      const mimeType = chooseMimeType();
      let mr = null;
      try{
        mr = mimeType ? new MediaRecorder(streamOut, { mimeType }) : new MediaRecorder(streamOut);
      }catch(err){
        console.error(err);
        showToast("MediaRecorder non disponibile in questo browser.", "bad");
        return;
      }

      state.recorder = mr;
      state.chunks = [];
      state.recording = true;
      state.recordStartTs = performance.now();

      $("#recBtn").classList.add("recording");
      $("#recHud").classList.add("on");
      $("#recStatus").textContent = "Registrazione‚Ä¶ (max 60s)";
      $("#timeLeft").textContent = `${MAX_SECONDS}s`;

      mr.ondataavailable = (e)=>{
        if(e.data && e.data.size > 0) state.chunks.push(e.data);
      };
      mr.onstop = async ()=>{
        try{
          const blob = new Blob(state.chunks, { type: mr.mimeType || "video/webm" });
          state.recordedBlob = blob;
          state.chunks = [];
          await openReview(blob);
        }catch(e){
          console.error(e);
          showToast("Errore nel salvataggio del video", "bad");
        }
      };

      mr.start(250); // small chunks for stability

      // Auto stop at 60s
      clearTimeout(state.stopTimer);
      state.stopTimer = setTimeout(()=>stopRecording(), MAX_SECONDS * 1000);

      // Update time left UI
      tickTimeLeft();
    }

    function tickTimeLeft(){
      if(!state.recording) return;
      const elapsed = (performance.now() - state.recordStartTs)/1000;
      const left = Math.max(0, Math.ceil(MAX_SECONDS - elapsed));
      $("#timeLeft").textContent = `${left}s`;
      if(left <= 0) return;
      requestAnimationFrame(tickTimeLeft);
    }

    function stopRecording(){
      if(!state.recording) return;
      state.recording = false;

      clearTimeout(state.stopTimer);
      state.stopTimer = null;

      $("#recBtn").classList.remove("recording");
      $("#recHud").classList.remove("on");
      $("#recStatus").textContent = "Pronto. Teleprompter sempre ON.";
      $("#timeLeft").textContent = `${MAX_SECONDS}s`;

      // Stop recorder
      try{
        state.recorder && state.recorder.state !== "inactive" && state.recorder.stop();
      }catch(e){}

      // Stop rendering loop (keep last frame?) -> stop after a beat
      setTimeout(()=>{
        if(state.rafId){
          cancelAnimationFrame(state.rafId);
          state.rafId = null;
        }
      }, 120);
    }

    /*****************************************************************
     * 10) Review modal: save to feed (IDB), download, discard
     *****************************************************************/
    const reviewModal = $("#reviewModal");
    const reviewVideo = $("#reviewVideo");
    const reviewMeta = $("#reviewMeta");
    let reviewUrl = null;

    async function openReview(blob){
      // Build caption + metadata now
      buildCaption();
      const hook = (state.hook || "").trim();
      const tags = DEFAULT_TAGS.slice(0,5).join(" ");

      // Set video
      if(reviewUrl) URL.revokeObjectURL(reviewUrl);
      reviewUrl = URL.createObjectURL(blob);
      reviewVideo.src = reviewUrl;
      reviewVideo.muted = false;
      reviewVideo.loop = true;
      reviewVideo.play().catch(()=>{});

      reviewMeta.textContent = `Titolo: ${hook || "‚Äî"}\nHashtag: ${tags}\n\nCaption:\n${state.caption}`;

      reviewModal.classList.add("show");
      reviewModal.setAttribute("aria-hidden","false");
    }

    function closeReview(){
      reviewModal.classList.remove("show");
      reviewModal.setAttribute("aria-hidden","true");
      reviewVideo.pause();
    }

    $("#closeReviewBtn").addEventListener("click", closeReview);
    $("#discardClipBtn").addEventListener("click", ()=>{
      state.recordedBlob = null;
      closeReview();
      showToast("Clip scartata", "good");
    });

    $("#downloadClipBtn").addEventListener("click", ()=>{
      if(!state.recordedBlob) return;
      const ts = new Date();
      const name = `clip_${ts.toISOString().replace(/[:.]/g,"-")}.webm`;
      downloadBlob(state.recordedBlob, name);
    });

    $("#saveClipBtn").addEventListener("click", async ()=>{
      if(!state.recordedBlob) return;
      const hook = (state.hook || "").trim();
      const hashtags = DEFAULT_TAGS.slice(0,5);
      buildCaption();
      const clip = {
        title: hook,
        caption: state.caption,
        hashtags,
        blob: state.recordedBlob,
        createdAt: Date.now()
      };
      try{
        await idbAddClip(clip);
        showToast("Salvato nel feed ‚úÖ", "good");
        closeReview();
        state.recordedBlob = null;
        await renderFeed();
        setTab("feed");
        $("#tabFeed").classList.add("active");
      }catch(e){
        console.error(e);
        showToast("Errore nel salvataggio in archivio", "bad");
      }
    });

    /*****************************************************************
     * 11) Feed rendering + autoplay visible (IntersectionObserver)
     *****************************************************************/
    const feedList = $("#feedList");
    let feedObserver = null;

    async function renderFeed(){
      const clips = (await idbGetAllClips())
        .sort((a,b)=>(b.createdAt||0)-(a.createdAt||0));

      // Clear old observer
      if(feedObserver){
        feedObserver.disconnect();
        feedObserver = null;
      }

      feedList.innerHTML = "";

      if(!clips.length){
        const empty = document.createElement("div");
        empty.className = "empty";
        empty.innerHTML = `
          <div>
            <div class="big">Nessun video salvato</div>
            <div>Registra un clip nel Recorder e salvalo qui. üëá</div>
          </div>
        `;
        feedList.appendChild(empty);
        return;
      }

      // Build items
      clips.forEach((clip)=>{
        const item = document.createElement("div");
        item.className = "feedItem";
        item.dataset.id = clip.id;

        const url = URL.createObjectURL(clip.blob);
        item.dataset.url = url;

        const vid = document.createElement("video");
        vid.src = url;
        vid.playsInline = true;
        vid.loop = true;
        vid.muted = true; // autoplay friendly
        vid.preload = "metadata";

        const meta = document.createElement("div");
        meta.className = "feedMeta";
        const tagsStr = (clip.hashtags || []).join(" ");
        meta.innerHTML = `
          <div class="pill">
            <div style="min-width:0;">
              <div class="title">${escapeHtml(clip.title || "‚Äî")}</div>
              <div class="tags">${escapeHtml(tagsStr)}</div>
            </div>
          </div>
        `;

        const actions = document.createElement("div");
        actions.className = "feedActions";
        actions.innerHTML = `
          <div class="fab" data-act="download" title="Download">‚¨áÔ∏è<br><small>DL</small></div>
          <div class="fab" data-act="delete" title="Elimina">üóëÔ∏è<br><small>DEL</small></div>
        `;

        actions.addEventListener("click", async (e)=>{
          const btn = e.target.closest("[data-act]");
          if(!btn) return;
          const act = btn.dataset.act;
          if(act === "download"){
            downloadBlob(clip.blob, `clip_${clip.id}.webm`);
          }
          if(act === "delete"){
            await deleteClip(clip.id);
          }
        });

        item.appendChild(vid);
        item.appendChild(meta);
        item.appendChild(actions);
        feedList.appendChild(item);
      });

      // IntersectionObserver autoplay only visible
      const vids = $$(".feedItem video");
      feedObserver = new IntersectionObserver((entries)=>{
        entries.forEach((en)=>{
          const v = en.target;
          if(en.isIntersecting && en.intersectionRatio >= 0.65){
            // pause others
            vids.forEach(o=>{ if(o!==v) o.pause(); });
            v.play().catch(()=>{});
          }else{
            v.pause();
          }
        });
      }, { root: feedList, threshold: [0, .35, .65, .9] });

      vids.forEach(v=>feedObserver.observe(v));
    }

    async function deleteClip(id){
      try{
        await idbDel("clips", id);
        showToast("Eliminato", "good");
        await renderFeed();
      }catch(e){
        console.error(e);
        showToast("Errore eliminazione", "bad");
      }
    }

    $("#wipeAllBtn").addEventListener("click", async ()=>{
      // minimal ‚Äúhard‚Äù wipe
      try{
        const clips = await idbGetAllClips();
        const tx = db.transaction("clips","readwrite");
        const st = tx.objectStore("clips");
        await Promise.all(clips.map(c=>new Promise((res,rej)=>{
          const r = st.delete(c.id);
          r.onsuccess=()=>res(true);
          r.onerror=()=>rej(r.error);
        })));
        showToast("Archivio svuotato", "good");
        await renderFeed();
      }catch(e){
        console.error(e);
        showToast("Errore nello svuotamento", "bad");
      }
    });

    function escapeHtml(s){
      return (s||"").replace(/[&<>"']/g, (c)=>({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
      }[c]));
    }

    /*****************************************************************
     * 12) Wire UI: Script builder actions + counters
     *****************************************************************/
    function updateCounts(){
      $("#qCount").textContent = `${($("#questionInput").value||"").trim().length}`;
      $("#aCount").textContent = `${($("#answerInput").value||"").trim().length}`;
    }
    $("#questionInput").addEventListener("input", ()=>{
      state.hook = $("#questionInput").value.trim();
      updateCounts();
      updateRecorderUITexts();
    });
    $("#answerInput").addEventListener("input", ()=>{
      state.script = $("#answerInput").value;
      updateCounts();
      updateRecorderUITexts();
    });

    $("#sendQuestionBtn").addEventListener("click", ()=>{
      const q = $("#questionInput").value.trim();
      if(!q){
        showToast("Scrivi la domanda (hook) prima di inviare.", "bad");
        $("#questionInput").focus();
        return;
      }
      state.hook = q;
      updateRecorderUITexts();
      showOverlay("DOMANDA (Hook)", q);
      showToast("Domanda inviata in overlay", "good");
    });

    $("#sendAnswerBtn").addEventListener("click", ()=>{
      const a = $("#answerInput").value.trim();
      if(!a){
        showToast("Scrivi la risposta (script) prima di inviare.", "bad");
        $("#answerInput").focus();
        return;
      }
      state.script = a;
      ensureLoopLine();
      $("#answerInput").value = state.script;
      updateCounts();
      updateRecorderUITexts();
      showOverlay("RISPOSTA (Script)", state.script);
      showToast("Risposta inviata in overlay", "good");
    });

    $("#pushToTeleprompterBtn").addEventListener("click", ()=>{
      // Push question->hook and answer->script
      const q = $("#questionInput").value.trim();
      const a = $("#answerInput").value.trim();
      if(!q){
        showToast("Manca la domanda (hook).", "bad");
        $("#questionInput").focus();
        return;
      }
      if(!a){
        showToast("Manca la risposta (script).", "bad");
        $("#answerInput").focus();
        return;
      }
      state.hook = q;
      state.script = $("#answerInput").value;
      ensureLoopLine();
      $("#answerInput").value = state.script;
      updateCounts();
      updateRecorderUITexts();
      showToast("Caricato nel teleprompter ‚úÖ", "good");
    });

    $("#copyCaptionBtn").addEventListener("click", async ()=>{
      buildCaption();
      try{
        await navigator.clipboard.writeText(state.caption);
        showToast("Caption copiata ‚úÖ", "good");
      }catch(e){
        showToast("Clipboard non disponibile", "bad");
      }
    });

    $("#goRecorderBtn").addEventListener("click", openRecorder);

    /*****************************************************************
     * 13) Recorder controls (REC button, sliders, nav)
     *****************************************************************/
    $("#zoomRange").addEventListener("input", ()=>{
      state.tpZoom = parseFloat($("#zoomRange").value);
      $("#zoomVal").textContent = `${state.tpZoom.toFixed(2)}√ó`;
      // reset lines so text wrap recalculates
      state.tpLines = [];
    });

    $("#speedRange").addEventListener("input", ()=>{
      state.tpSpeed = parseFloat($("#speedRange").value);
      $("#spdVal").textContent = `${Math.round(state.tpSpeed)} px/s`;
    });

    $("#recBtn").addEventListener("click", async ()=>{
      if(state.recording){
        stopRecording();
      }else{
        await startRecording();
      }
    });

    $("#backToScriptBtn").addEventListener("click", openScript);
    $("#openFeedBtn").addEventListener("click", openFeed);
    $("#feedToRecBtn").addEventListener("click", openRecorder);

    // Tabs
    $("#tabScript").addEventListener("click", openScript);
    $("#tabRec").addEventListener("click", openRecorder);
    $("#tabFeed").addEventListener("click", openFeed);

    /*****************************************************************
     * 14) Boot: open DB, restore logo, init caption, minimal guards
     *****************************************************************/
    async function boot(){
      // HTTPS/localhost reminder (no blocking)
      if(!(location.protocol === "https:" || location.hostname === "localhost" || location.hostname === "127.0.0.1")){
        showToast("Nota: camera funziona solo su https/localhost.", "bad");
      }

      try{
        db = await openDB();
      }catch(e){
        console.error(e);
        showToast("IndexedDB non disponibile: logo/feed non persistono.", "bad");
      }

      // Restore logo if present
      if(db){
        const savedLogo = await idbGet("settings","logo").catch(()=>null);
        if(savedLogo){
          state.logoBlob = savedLogo;
          await loadLogoBitmapFromBlob(savedLogo);
          $("#logoStatus").textContent = "Logo caricato (persistente)";
        }else{
          $("#logoStatus").textContent = "Nessun logo";
        }
      }

      updateCounts();
      buildCaption();

      // UX: keep caption preview updated even with empty
      updateRecorderUITexts();

      // Light ‚Äúperformance‚Äù tweak: pause review modal video on background
      document.addEventListener("visibilitychange", ()=>{
        if(document.hidden){
          try{ reviewVideo.pause(); }catch(e){}
        }
      });
    }

    boot();
  </script>
</body>
</html>
